C51 COMPILER V9.52.0.0   SOFT_IIC                                                          11/24/2017 09:42:42 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SOFT_IIC
OBJECT MODULE PLACED IN .\Objects\SOFT_IIC.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\IIC\SOFT_IIC.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\project;.\U
                    -SER\BUZZER;.\USER\charge;.\USER\common;.\USER\DC_MOTOR;.\USER\EEPROM;.\USER\EXINT;.\USER\IIC;.\USER\inc;.\USER\ION;.\USE
                    -R\M26;.\USER\PWM;.\USER\Sensor;.\USER\step_motor;.\USER\SYS_RUN;.\USER\timer;.\USER\TM1620;.\USER\touch_key;.\USER\UART;
                    -.\USER\UV;.\USER\LVI) DEBUG OBJECTEXTEND PRINT(.\Listings\SOFT_IIC.lst) TABS(2) OBJECT(.\Objects\SOFT_IIC.obj)

line level    source

   1          #include "SOFT_IIC.h"
   2          
   3          #include "sensor.h"
   4          
   5          /*
   6          void Set_SDA_Pin_Mode(unsigned char mode)
   7          {
   8              if(mode == PIN_INPUT)
   9              {
  10                  //PIN设置为输入时，PxM0对应的位置0，PxM1对应的位置1
  11                  SOFT_IIC_PxM0 &= ~(1 << SOFT_IIC_SDA_PORTBIT);
  12                  SOFT_IIC_PxM1 |= ((1 << SOFT_IIC_SDA_PORTBIT));
  13              }
  14              else if(mode == PIN_OUTPUT)
  15              {      
  16                  SOFT_IIC_PxM0 &= ~(1 << SOFT_IIC_SDA_PORTBIT);
  17                  SOFT_IIC_PxM1 &= ~(1 << SOFT_IIC_SDA_PORTBIT);
  18              }
  19          }
  20          
  21          void Set_SCL_Pin_Mode(unsigned char mode)
  22          {
  23              if(mode == PIN_INPUT)
  24              {
  25                  //PIN设置为输入时，PxM0对应的位置0，PxM1对应的位置1
  26                  SOFT_IIC_PxM0 &= ~(1 << SOFT_IIC_SCL_PORTBIT);
  27                  SOFT_IIC_PxM1 |= ((1 << SOFT_IIC_SCL_PORTBIT));
  28              }
  29              else if(mode == PIN_OUTPUT)
  30              {      
  31                  SOFT_IIC_PxM0 &= ~(1 << SOFT_IIC_SCL_PORTBIT);
  32                  SOFT_IIC_PxM1 &= ~(1 << SOFT_IIC_SCL_PORTBIT);     
  33              }
  34          }
  35          
  36          void Soft_IIC_PinConifg(void)
  37          {
  38              //PIN设置为推挽输出，PxM0对应的位置1，PxM1对应的位置0  
  39              SOFT_IIC_PxM0 &= ~((1 << SOFT_IIC_SDA_PORTBIT) | (1 << SOFT_IIC_SCL_PORTBIT));
  40              SOFT_IIC_PxM1 &= ~((1 << SOFT_IIC_SDA_PORTBIT) | (1 << SOFT_IIC_SCL_PORTBIT));
  41            
  42              SOFT_IIC_SCL_PIN = 1;
  43              SOFT_IIC_SDA_PIN = 1;
  44          }
  45          
  46          #define IIC_DELAY_COUNT  10
  47          
  48          static void i2c_delay(void)
  49          {
  50            int i = 0;
  51            for(i = 0;i < IIC_DELAY_COUNT;i++);
  52          }
C51 COMPILER V9.52.0.0   SOFT_IIC                                                          11/24/2017 09:42:42 PAGE 2   

  53          
  54          */
  55          
  56          IIC_Operations_Typedef IIC_Operations;
  57          
  58          static void i2c_delay1(unsigned int num)
  59          {
  60   1        int i = 0;
  61   1        for(i = 0;i < num;i++);
  62   1      }
  63          
  64          
  65          
  66          //**********启动读写时序子函数**********
  67          void I2C_start(void)
  68          {
  69   1        IIC_Operations.Set_SDA_Pin_Mode(PIN_OUTPUT);
  70   1        IIC_Operations.SDA_1();
  71   1        IIC_Operations.i2c_delay();
  72   1        IIC_Operations.SCL_1();
  73   1        IIC_Operations.i2c_delay();
  74   1        IIC_Operations.SDA_0();
  75   1        IIC_Operations.i2c_delay();
  76   1        IIC_Operations.SCL_0();
  77   1        IIC_Operations.i2c_delay();
  78   1      }
  79          
  80          
  81          //**********停止操作子函数**********
  82          void I2C_stop(void)
  83          {
  84   1        IIC_Operations.Set_SDA_Pin_Mode(PIN_OUTPUT);
  85   1        IIC_Operations.SDA_0();
  86   1        IIC_Operations.i2c_delay();
  87   1        IIC_Operations.SCL_1();
  88   1        IIC_Operations.i2c_delay();
  89   1        IIC_Operations.SDA_1();
  90   1        IIC_Operations.i2c_delay();
  91   1        
  92   1      }
  93          
  94          /*
  95          *********************************************************************************************************
  96          * 函 数 名: i2c_WaitAck
  97          * 功能说明: CPU产生一个时钟，并读取器件的ACK应答信号
  98          * 形    参：无
  99          * 返 回 值: 返回0表示正确应答，1表示无器件响应
 100          *********************************************************************************************************
 101          */
 102          unsigned char I2C_WaitAck(void)
 103          {
 104   1        unsigned char re = 0;
 105   1        
 106   1        IIC_Operations.SDA_1(); /* CPU释放SDA总线 */
 107   1        
 108   1        IIC_Operations.Set_SDA_Pin_Mode(PIN_INPUT);
 109   1        
 110   1        IIC_Operations.i2c_delay();
 111   1        IIC_Operations.SCL_1(); /* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
 112   1        IIC_Operations.i2c_delay();
 113   1        
 114   1        if (IIC_Operations.I2C_SDA_READ())  /* CPU读取SDA口线状态 */
C51 COMPILER V9.52.0.0   SOFT_IIC                                                          11/24/2017 09:42:42 PAGE 3   

 115   1        {
 116   2          re = 1;
 117   2        }
 118   1        else
 119   1        {
 120   2          re = 0;
 121   2        }
 122   1        IIC_Operations.SCL_0();
 123   1        IIC_Operations.i2c_delay();
 124   1        return re;
 125   1      }
 126          
 127          /*响应*/
 128          void I2C_Ack(void)
 129          {
 130   1        IIC_Operations.Set_SDA_Pin_Mode(PIN_OUTPUT);
 131   1        IIC_Operations.SDA_0(); /* CPU驱动SDA = 0 */
 132   1        IIC_Operations.i2c_delay();
 133   1        IIC_Operations.SCL_1(); /* CPU产生1个时钟 */
 134   1        IIC_Operations.i2c_delay();
 135   1        IIC_Operations.SCL_0();
 136   1        IIC_Operations.i2c_delay();
 137   1        IIC_Operations.SDA_1(); /* CPU释放SDA总线 */
 138   1      }
 139          
 140          
 141          /*
 142          *********************************************************************************************************
 143          * 函 数 名: i2c_NAck
 144          * 功能说明: CPU产生1个NACK信号
 145          * 形    参：无
 146          * 返 回 值: 无
 147          *********************************************************************************************************
 148          */
 149          void I2C_NAck(void)
 150          {
 151   1        IIC_Operations.Set_SDA_Pin_Mode(PIN_OUTPUT);
 152   1        IIC_Operations.SDA_1(); /* CPU驱动SDA = 1 */
 153   1        IIC_Operations.i2c_delay();
 154   1        IIC_Operations.SCL_1(); /* CPU产生1个时钟 */
 155   1        IIC_Operations.i2c_delay();
 156   1        IIC_Operations.SCL_0();
 157   1        IIC_Operations.i2c_delay(); 
 158   1      }
 159          
 160          
 161          
 162          //**********写入8位子函数**********
 163          void I2C_SendOneByte(unsigned char a)
 164          {
 165   1        unsigned char temp;
 166   1        unsigned char i, j;
 167   1      
 168   1        IIC_Operations.Set_SDA_Pin_Mode(PIN_OUTPUT);
 169   1        temp = a;
 170   1        for(i=0;i<8;i++)
 171   1        {
 172   2            j=temp&0x80;
 173   2          if(j==0)
 174   2          {
 175   3            IIC_Operations.SDA_0();
 176   3          }
C51 COMPILER V9.52.0.0   SOFT_IIC                                                          11/24/2017 09:42:42 PAGE 4   

 177   2          else
 178   2          {
 179   3            IIC_Operations.SDA_1();
 180   3          }
 181   2          IIC_Operations.SCL_1();
 182   2          IIC_Operations.i2c_delay();
 183   2          IIC_Operations.SCL_0();
 184   2          IIC_Operations.i2c_delay();
 185   2          temp = temp<<1;
 186   2        }
 187   1        
 188   1      }
 189          
 190          
 191          unsigned char I2C_ReadOneByte(void)
 192          {
 193   1        unsigned char i;
 194   1        unsigned char value;
 195   1      
 196   1        /* 读到第1个bit为数据的bit7 */
 197   1        value = 0;
 198   1        IIC_Operations.Set_SDA_Pin_Mode(PIN_INPUT);
 199   1        for (i = 0; i < 8; i++)
 200   1        {
 201   2          value <<= 1;
 202   2          IIC_Operations.SCL_1();
 203   2          IIC_Operations.i2c_delay();
 204   2          if (IIC_Operations.I2C_SDA_READ())
 205   2          {
 206   3            value |= 1;
 207   3          }
 208   2          IIC_Operations.SCL_0();
 209   2          IIC_Operations.i2c_delay();
 210   2        }
 211   1        return value;
 212   1      }
 213          
 214          
 215          
 216          
 217          
 218          /**
 219            * @brief   使用IIC读取数据
 220            * @param   
 221            *   @arg ClientAddr:从设备地址
 222            *   @arg pBuffer:存放由从机读取的数据的缓冲区指针
 223            *   @arg readAddr:表示读取从设备哪个寄存器的数据
 224            *   @arg NumByteToRead:读取的数据长度
 225            * @retval  无
 226            */
 227          unsigned int I2C_ReadBytes(unsigned char ClientAddr, unsigned char* pBuffer,unsigned int NumByteToRead)
 228          {
 229   1        
 230   1        /* 第1步：发起I2C总线启动信号 */
 231   1        I2C_start();
 232   1        
 233   1        /* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
 234   1        I2C_SendOneByte((ClientAddr << 1) | I2C_DIR_RD);  /* 此处是读指令 */
 235   1          
 236   1        /* 第3步：等待ACK */
 237   1        if (I2C_WaitAck() != 0)
 238   1        {
C51 COMPILER V9.52.0.0   SOFT_IIC                                                          11/24/2017 09:42:42 PAGE 5   

 239   2          goto cmd_fail;  /* 器件无应答 */
 240   2        }
 241   1      
 242   1        while(NumByteToRead) 
 243   1        {
 244   2           
 245   2           if(IIC_Operations.IIC_NUM == TOUCH_KEY_IIC)
 246   2           {
 247   3             //跟触摸芯片通讯每发送或者接收完一个字节后必须延时较长的时间，否则通讯会出问题
 248   3             i2c_delay1(100);   
 249   3           }
 250   2           else if(IIC_Operations.IIC_NUM == HPD05_IIC)
 251   2           {
 252   3             i2c_delay1(10);
 253   3           }
 254   2           
 255   2          
 256   2          *pBuffer = I2C_ReadOneByte();
 257   2          
 258   2          /* 读指针自增 */
 259   2          pBuffer++; 
 260   2            
 261   2          /*计数器自减 */
 262   2          NumByteToRead--;
 263   2      
 264   2          if (NumByteToRead == 0)
 265   2          {
 266   3            I2C_NAck(); /* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
 267   3      
 268   3            /* 发送I2C总线停止信号 */
 269   3            //I2C_stop();
 270   3            break;
 271   3          }
 272   2          
 273   2          I2C_Ack();  /* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */ 
 274   2      
 275   2       
 276   2        }
 277   1      
 278   1        /* 发送I2C总线停止信号 */
 279   1        I2C_stop();
 280   1        return 0; /* 执行成功 */
 281   1      
 282   1      cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
 283   1        /* 发送I2C总线停止信号 */
 284   1        I2C_stop();
 285   1        return 1;
 286   1      }
 287          
 288          
 289          /**
 290            * @brief   使用IIC写入数据
 291            * @param   
 292            *   @arg ClientAddr:从设备地址
 293            *   @arg pBuffer:缓冲区指针
 294            *     @arg NumByteToWrite:写的字节数
 295            * @retval  无
 296            */
 297          unsigned int I2C_WriteBytes(unsigned char ClientAddr, unsigned char* pBuffer, unsigned int NumByteToWrite)
 298          {
 299   1        //unsigned int m; 
 300   1      
C51 COMPILER V9.52.0.0   SOFT_IIC                                                          11/24/2017 09:42:42 PAGE 6   

 301   1        /*　第0步：发停止信号，启动内部写操作　*/
 302   1        I2C_stop();
 303   1        
 304   1        /* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms      
 305   1          CLK频率为200KHz时，查询次数为30次左右
 306   1        */    
 307   1          /* 第1步：发起I2C总线启动信号 */
 308   1          I2C_start();
 309   1          
 310   1          /* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
 311   1          I2C_SendOneByte((ClientAddr << 1) | I2C_DIR_WR);  /* 此处是写指令 */
 312   1          
 313   1          /* 第3步：发送一个时钟，判断器件是否正确应答 */
 314   1          if (I2C_WaitAck() == 0)
 315   1          {
 316   2            //break;
 317   2          }
 318   1          else
 319   1         {
 320   2            goto cmd_fail;
 321   2         }
 322   1        
 323   1        
 324   1        while(NumByteToWrite)
 325   1        {
 326   2           if(IIC_Operations.IIC_NUM == TOUCH_KEY_IIC)
 327   2           {
 328   3             //跟触摸芯片通讯每发送或者接收完一个字节后必须延时较长的时间，否则通讯会出问题
 329   3             i2c_delay1(100);   
 330   3           }
 331   2           else if(IIC_Operations.IIC_NUM == HPD05_IIC)
 332   2           {
 333   3             i2c_delay1(10);
 334   3           }
 335   2            /* 第4步：开始写入数据 */
 336   2            I2C_SendOneByte(*pBuffer);
 337   2      
 338   2            /* 第5步：检查ACK */
 339   2            if (I2C_WaitAck() != 0)
 340   2            {
 341   3                goto cmd_fail;  /* 器件无应答 */
 342   3            }
 343   2            
 344   2            NumByteToWrite--;
 345   2            
 346   2            if(NumByteToWrite == 0)
 347   2            {
 348   3                goto end;
 349   3            }
 350   2            
 351   2            pBuffer++;  /* 地址增1 */   
 352   2            
 353   2           
 354   2        }
 355   1        
 356   1        /* 命令执行成功，发送I2C总线停止信号 */
 357   1      end:
 358   1        i2c_delay1(60);
 359   1        I2C_stop();
 360   1        return 0;
 361   1      
 362   1      cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
C51 COMPILER V9.52.0.0   SOFT_IIC                                                          11/24/2017 09:42:42 PAGE 7   

 363   1        /* 发送I2C总线停止信号 */
 364   1        I2C_stop();
 365   1        return 1;
 366   1      }
 367          
 368          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1072    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     28      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
