C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/21/2017 11:02:13 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE TOUCH_KEY
OBJECT MODULE PLACED IN .\Objects\touch_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\touch_key\touch_key.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\proj
                    -ect;.\USER\BUZZER;.\USER\charge;.\USER\common;.\USER\DC_MOTOR;.\USER\EEPROM;.\USER\EXINT;.\USER\IIC;.\USER\inc;.\USER\IO
                    -N;.\USER\M26;.\USER\PWM;.\USER\Sensor;.\USER\step_motor;.\USER\SYS_RUN;.\USER\timer;.\USER\TM1620;.\USER\touch_key;.\USE
                    -R\UART;.\USER\UV;.\USER\LVI) DEBUG OBJECTEXTEND PRINT(.\Listings\touch_key.lst) TABS(2) OBJECT(.\Objects\touch_key.obj)

line level    source

   1          #include <stdio.h>
   2          #include "touch_key.h"
   3          #include "SOFT_IIC.h"
   4          #include "timer.h"
   5          #include "global.h"
   6          #include "debug_uart.h"
   7          #include "common.h"
   8          
   9          
  10          KEY_INFO_Typedef  key_info;
  11          
  12          
  13          #define KEY_IIC_DELAY_COUNT  10
  14          
  15          void key_i2c_delay(void)
  16          {
  17   1        int i = 0;
  18   1        for(i = 0;i < KEY_IIC_DELAY_COUNT;i++);
  19   1      }
  20          
  21          
  22          void Key_IIC_PinConifg(void)
  23          {
  24   1           
  25   1          KEY_IIC_PxM0 &= ~((1 << KEY_IIC_SDA_PORTBIT) | (1 << KEY_IIC_SCL_PORTBIT));
  26   1          KEY_IIC_PxM1 &= ~((1 << KEY_IIC_SDA_PORTBIT) | (1 << KEY_IIC_SCL_PORTBIT));
  27   1        
  28   1          KEY_IIC_SCL_PIN = 1;
  29   1          KEY_IIC_SDA_PIN = 1;
  30   1      }
  31          
  32          
  33          
  34          void Set_KEY_SDA_Pin_Mode(unsigned char mode)
  35          {
  36   1          if(mode == PIN_INPUT)
  37   1          {
  38   2              //PIN设置为输入时，PxM0对应的位置0，PxM1对应的位置1
  39   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SDA_PORTBIT);
  40   2              KEY_IIC_PxM1 |= (1 << KEY_IIC_SDA_PORTBIT);
  41   2          }
  42   1          else if(mode == PIN_OUTPUT)
  43   1          {      
  44   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SDA_PORTBIT);
  45   2              KEY_IIC_PxM1 &= ~(1 << KEY_IIC_SDA_PORTBIT);
  46   2          }
  47   1      }
  48            
  49          void Set_KEY_SCL_Pin_Mode(unsigned char mode)
  50          {
  51   1          if(mode == PIN_INPUT)
  52   1          {
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/21/2017 11:02:13 PAGE 2   

  53   2              //PIN设置为输入时，PxM0对应的位置0，PxM1对应的位置1
  54   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SCL_PORTBIT);
  55   2              KEY_IIC_PxM1 |= ((1 << KEY_IIC_SCL_PORTBIT));
  56   2          }
  57   1          else if(mode == PIN_OUTPUT)
  58   1          {      
  59   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SCL_PORTBIT);
  60   2              KEY_IIC_PxM1 &= ~(1 << KEY_IIC_SCL_PORTBIT);     
  61   2          }
  62   1      
  63   1      }
  64          
  65          
  66          void Key_IIC_SDA_1(void)
  67          {
  68   1          KEY_IIC_SDA_PIN = 1;
  69   1      }
  70          
  71          void Key_IIC_SDA_0(void)
  72          {
  73   1          KEY_IIC_SDA_PIN = 0;
  74   1      }
  75          
  76          void Key_IIC_SCL_1(void)
  77          {
  78   1          KEY_IIC_SCL_PIN = 1;
  79   1      }
  80          void Key_IIC_SCL_0(void)
  81          {
  82   1          KEY_IIC_SCL_PIN = 0;
  83   1      }
  84          
  85          
  86          unsigned char Key_IIC_SDA_READ(void)
  87          {
  88   1          return (KEY_IIC_SDA_PIN ? 1 : 0);
  89   1      }
  90          
  91          
  92          
  93          void Get_Key_Status(unsigned char *key_status)
  94          {
  95   1          const unsigned char readaddr = 0x17;
  96   1          unsigned char res = 1;
  97   1        
  98   1          IIC_Operations.IIC_NUM = TOUCH_KEY_IIC;
  99   1          IIC_Operations.Set_SDA_Pin_Mode = Set_KEY_SDA_Pin_Mode;
 100   1          IIC_Operations.Set_SCL_Pin_Mode = Set_KEY_SCL_Pin_Mode;
 101   1          IIC_Operations.i2c_delay = key_i2c_delay;
 102   1          IIC_Operations.SDA_1 = Key_IIC_SDA_1;
 103   1          IIC_Operations.SDA_0 = Key_IIC_SDA_0;
 104   1          IIC_Operations.SCL_1 = Key_IIC_SCL_1;
 105   1          IIC_Operations.SCL_0 = Key_IIC_SCL_0;
 106   1          IIC_Operations.I2C_SDA_READ = Key_IIC_SDA_READ;
 107   1        
 108   1          
 109   1          res = I2C_WriteBytes(OB39A08T1_ADDRESS,&readaddr,1);
 110   1          if(res == 0)
 111   1          {
 112   2              I2C_ReadBytes(OB39A08T1_ADDRESS,key_status,3);
 113   2          }
 114   1          
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/21/2017 11:02:13 PAGE 3   

 115   1      }
 116          
 117          unsigned char Scan_TouchPad(void)
 118          {
 119   1          static unsigned char wifi_key_count_times = 0;
 120   1          //unsigned char whichkey = 0;
 121   1          unsigned char temp_status0,temp_status1 = 0;
 122   1          static unsigned char last_status0,last_status1 = 0;
 123   1        
 124   1          //unsigned char debug_buff[20] = {0};
 125   1        
 126   1          unsigned char key_status[3] = {0};
 127   1          
 128   1          //如果上电后检测到仓门坏了，则按键不起作用
 129   1          //如果仓门正在工作则按键不起作用
 130   1          if(IsStepMotorBusy)
 131   1          {
 132   2              return 0xFF;
 133   2          }
 134   1          
 135   1          Get_Key_Status(key_status);
 136   1        
 137   1          temp_status0 = key_status[2];
 138   1          temp_status1 = key_status[1];
 139   1        
 140   1          //POWER按键和其他按键不能同时按下
 141   1          if((temp_status0 == 0 && temp_status1 == 0) || (temp_status0 != 0 && temp_status1 != 0))
 142   1          {
 143   2              last_status0 = 0;
 144   2              last_status1 = 0;
 145   2            
 146   2              wifi_key_count_times = 0;
 147   2      
 148   2              Clear_Touch_Info();
 149   2              return 0;
 150   2          }
 151   1          
 152   1          if(temp_status0 != 0)
 153   1          {
 154   2              if(temp_status0 != last_status0)
 155   2              {
 156   3                  key_info.IsCount = 1;
 157   3                  key_info.count_times = 0;
 158   3                  key_info.IsTouchedKey = 0;
 159   3                  key_info.WhichKey = KEY_NONE;
 160   3              }
 161   2          }
 162   1          
 163   1          if(temp_status1 != 0)
 164   1          {
 165   2              if(temp_status1 != last_status1)
 166   2              {
 167   3                  key_info.IsCount = 1;
 168   3                  key_info.count_times = 0;
 169   3                  key_info.IsTouchedKey = 0;
 170   3                  key_info.WhichKey = KEY_NONE;
 171   3              }
 172   2          }
 173   1          
 174   1          if(key_info.count_times >= (KEY_TOUCH_MS_TIMES * TIMER_BASE))
 175   1          {
 176   2              //一个按键计数完毕后停止计数，防止一直按着一个按键不松开
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/21/2017 11:02:13 PAGE 4   

 177   2              if(temp_status1 != KEY_WIFI_VALUE)
 178   2              {
 179   3                  key_info.IsCount = 0;
 180   3                  key_info.count_times = 0;
 181   3                
 182   3                  //如果不是按下wifi组合键，先把wifi计数清零
 183   3                  wifi_key_count_times = 0;
 184   3              }
 185   2              else
 186   2              {
 187   3                  //如果按下的是WIFI按键，则从0重新开始计数，直到检测到按下2秒钟以后再停止
 188   3                  key_info.count_times = 0;
 189   3              }
 190   2      
 191   2              
 192   2              if(temp_status0 != 0)
 193   2              {
 194   3                  if(temp_status0 == KEY_POWER_VALUE)
 195   3                  {
 196   4                      key_info.IsTouchedKey = 1;
 197   4                      key_info.WhichKey = KEY_POWER;
 198   4                  }
 199   3                  else
 200   3                  {
 201   4                      key_info.IsTouchedKey = 0;
 202   4                      key_info.WhichKey = KEY_NONE;
 203   4                  }
 204   3                  
 205   3                  wifi_key_count_times = 0;
 206   3              }
 207   2              
 208   2              if(temp_status1 != 0)
 209   2              {         
 210   3                  if(temp_status1 == KEY_SPEED_VALUE)
 211   3                  {
 212   4                      key_info.IsTouchedKey = 1;
 213   4                      key_info.WhichKey = KEY_SPEED;
 214   4                  }
 215   3                  else if(temp_status1 == KEY_TIMER_VALUE)
 216   3                  {
 217   4                      key_info.IsTouchedKey = 1;
 218   4                      key_info.WhichKey = KEY_TIMER;
 219   4                  }
 220   3                  else if(temp_status1 == KEY_MODE_VALUE)
 221   3                  {
 222   4                      key_info.IsTouchedKey = 1;
 223   4                      key_info.WhichKey = KEY_MODE;
 224   4                  }    
 225   3                  else if(temp_status1 == KEY_WIFI_VALUE)
 226   3                  {
 227   4                    
 228   4                      wifi_key_count_times += 1;
 229   4      //                mymemset(debug_buff,0,mystrlen(debug_buff));
 230   4      //                sprintf(debug_buff,"wifi_times:%d\n",(unsigned int)wifi_key_count_times);  
 231   4      //                DEBUG_Uart_Sendbytes(debug_buff,mystrlen(debug_buff));  
 232   4                    
 233   4                      if(wifi_key_count_times >= (2000 / KEY_TOUCH_MS_TIMES))
 234   4                      {
 235   5                          key_info.IsTouchedKey = 1;
 236   5                          key_info.WhichKey = KEY_WIFI;
 237   5                        
 238   5                          //停止中断中的计数
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/21/2017 11:02:13 PAGE 5   

 239   5                          key_info.IsCount = 0;
 240   5                          key_info.count_times = 0;
 241   5                          //此处wifi_key_count_times不清零，防止一直按着组合键不松开，松开按键后再清零
 242   5                      }
 243   4                    
 244   4                      
 245   4      //                key_info.IsTouchedKey = 1;
 246   4      //                key_info.WhichKey = KEY_WIFI;
 247   4      
 248   4                  }              
 249   3                  else
 250   3                  {
 251   4                      key_info.IsTouchedKey = 0;
 252   4                      key_info.WhichKey = KEY_NONE;            
 253   4                  }
 254   3                  
 255   3      
 256   3              }
 257   2                 
 258   2          }
 259   1              
 260   1          last_status0 = temp_status0;    
 261   1          last_status1 = temp_status1;
 262   1          
 263   1          return key_info.WhichKey;
 264   1      }
 265          
 266          
 267          void Clear_Touch_Info(void)
 268          {
 269   1          key_info.IsCount = 0;
 270   1          key_info.count_times = 0;
 271   1          key_info.IsTouchedKey = 0;
 272   1          key_info.WhichKey = KEY_NONE;
 273   1      }
 274          
 275          
 276          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    618    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =      9       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
