C51 COMPILER V9.52.0.0   SOFT_UART_1                                                       01/24/2018 16:50:50 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SOFT_UART_1
OBJECT MODULE PLACED IN .\Objects\soft_uart_1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\UART\soft_uart_1.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER\IIC
                    -;.\USER\UART;.\USER\TM1618;.\USER\Sensor;.\USER;.\USER\PWM;.\USER\DC_MOTOR;.\USER\timer;.\USER\inc;.\USER\EXINT;.\USER\t
                    -ouch_key;.\USER\SYS_RUN;.\USER\step_motor;.\USER\BUZZER;.\USER\UART;.\USER\common;.\USER\lib;.\USER\UV;.\USER\ION;.\USER
                    -\EEPROM;.\USER\TM1620;.\USER\user_timer) DEBUG OBJECTEXTEND PRINT(.\Listings\soft_uart_1.lst) TABS(2) OBJECT(.\Objects\s
                    -oft_uart_1.obj)

line level    source

   1          #include "OB39R16A6.h"
   2          #include "soft_uart.h"
   3          #include "global.h"
   4          #include "wifi_uart.h"
   5          #include "debug_uart.h"
   6          //#include "TM1618.h"
   7          /*
   8          //时钟周期 22.1184MHz
   9          1秒的机器周期为 22118400/12
  10          
  11          
  12          1ms的需要的机器周期为 22118.4/12
  13          22118.4/12 = 1843.2(0x0733)
  14          65536 - 1843 = 43418（0xF8CD）
  15          
  16          0.5ms需要的机器周期为 22118.4/12/2 = 921.6
  17          65536 - 921  = 64615(0xFC67)
  18          
  19          0.25ms需要的机器周期为 22118.4/12/2/2 = 460.8
  20          65536 - 461  = 65075(0xFE33)
  21          
  22          0.1ms需要的机器周期为 22118.4/12/10 = 184.32
  23          65536 - 184  = 65352(0xFF48)
  24          
  25          0.05ms = 50us 需要的机器周期为 22118.4/12/10/2 = 92.16
  26          65536 - 92  = 65444(0xFFA4)
  27          
  28          104.17us = 0.10417ms 需要的机器周期为 (22118.4/12)/(1/0.10417) = 192 对应的波特率 9600
  29          TMIER1采用模式2,8bit- autoreload模式 TH1 = 256 - 192 = 64 
  30          
  31          34.7us = 0.0347ms 需要的机器周期为 (22118.4/12)/(1/0.0347) = 63.96 = 64  对应的波特率为 9600*3
  32          TMIER1采用模式2,8bit- autoreload模式 TH1 = 256 - 64 = 192 
  33          */
  34          
  35          //定时器为104.17us时 U2RxRate_bk = 1；定时器为34.7s时 U2RxRate_bk = 3；
  36          static unsigned char U2RxRate_bk = 0;
  37          static unsigned char U2TxRate_bk = 0;
  38          static unsigned char U3RxRate_bk = 0;
  39          static unsigned char U3TxRate_bk = 0;
  40          
  41          #define d_T0MOD    0x20
  42          #define d_T0_TH0   192
  43          
  44          void Timer0_Init(void)
  45          {
  46   1          ET0 = 1;
  47   1          TMOD  |= d_T0MOD;
  48   1          TH0   = d_T0_TH0;  //MODE1 16bit
  49   1          //TL0   = d_T0_TL0;
  50   1          EA   = 1;
  51   1          TR0  = 1;
C51 COMPILER V9.52.0.0   SOFT_UART_1                                                       01/24/2018 16:50:50 PAGE 2   

  52   1      }
  53          
  54          void Soft_UART_Init(void)
  55          {
  56   1          Timer0_Init();
  57   1        
  58   1      #ifdef WIFI_SOFT_UART
                  U2RxRate_bk = 3;
                  U2TxRate_bk = 3;
              #endif
  62   1        
  63   1          U3RxRate_bk = 3;
  64   1          U3TxRate_bk = 3;
  65   1      }
  66          
  67          
  68          
  69          
  70          
  71          /*********************
  72          High priority interupt
  73          TIMER1  34.7us timer, 9600*3 bps
  74          中断函数内部勿使用耗时的函数，否则模拟UART的发送和接收比特率会出问题
  75          ******************/
  76          void TIMER0_ISR(void) interrupt d_T0_Vector
  77          { 
  78   1      #ifdef WIFI_SOFT_UART
                  static unsigned char U2RxBitCount = 0;
                  static unsigned char U2RxBuf = 0;
                  static unsigned char U2TxBuf = 0;
                  static unsigned char U2RxRate = 0;
              #endif
  84   1        
  85   1          static unsigned char U3RxBitCount = 0;
  86   1          static unsigned char U3RxBuf = 0;
  87   1          static unsigned char U3TxBuf = 0;
  88   1          static unsigned char U3RxRate = 0;
  89   1      
  90   1       /*模拟 UART2函数*/   
  91   1      #ifdef WIFI_SOFT_UART 
                // Rx
                if(U2RxPtr < U2RxBuff_MAXSIZE)
                {
                  if(U2RxBitCount)
                  {
                    if(!--U2RxRate)
                    {
                      //用两个判断 U2RxBitCount==9,此处是延时一个停止位
                      if(U2RxBitCount == 9)
                      {
                        U2RxBitCount = 0;   //stop Rxing
                        U2RxBuffer[U2RxPtr++] = U2RxBuf;
                        U2RxBuf = 0;
                        //U2RxRate = U2RxRate_bk;
                        IsU2RxBusy = 0;
                        
                      }
                      else
                      {
                        U2RxRate = U2RxRate_bk;
                        if(U2RxPin)
                        {
C51 COMPILER V9.52.0.0   SOFT_UART_1                                                       01/24/2018 16:50:50 PAGE 3   

                            U2RxBuf |= (1 << 7);
                        }
                        else
                        { 
                            U2RxBuf &= ~(1 << 7);
                        }
                        
                        U2RxBitCount++;
                        if(U2RxBitCount == 9)
                        {
                            U2RxRate = U2RxRate_bk;
                            return;
                        }
                        U2RxBuf >>= 1;          
                      }
                    }
                  }
                  else
                  {
                    if(!U2RxPin)
                    {
                      U2RxBitCount = 1;   //start Rx
                      U2RxRate = U2RxRate_bk + 1;
                      IsU2RxBusy = 1;
                    }
                  }  
                }
              
                
                
                //to initiate a Tx, just write the U8 data to U2TxBuf,and set U2TxBitCount = 10 ,U2TxRate set to 3
                //first check if it's Txing (if U2TxBitCount != 0), 
              
                
                if(U2TxBitCount){
                  if(!--U2TxRate){
                    U2TxRate = U2TxRate_bk;
                    //
                    switch(U2TxBitCount --){
                      case 1:   //Stop bit; send next byte
                        U2TxPin = 1;
                        if(U2TxPtr != U2LdPtr){
                          U2TxBuf = U2TxBuffer[U2TxPtr ++];
                          U2TxBitCount = 10;
                        }
                        else{
                          U2TxPtr = 0;
                          U2LdPtr = 0;
                          IsU2TxBusy = 0;
                        }
                      break;
              
                      case 10:  //Start bit
                        IsU2TxBusy = 1;
                        U2TxPin = 0;
                        if(U2TxPtr == 0)
                        {
                          U2TxBuf = U2TxBuffer[U2TxPtr ++];
                        }
                      break;
                      
                      default:
C51 COMPILER V9.52.0.0   SOFT_UART_1                                                       01/24/2018 16:50:50 PAGE 4   

                        //U2TxPin = U2TxBuf & 0XFE;
                        U2TxPin = U2TxBuf & 0x01;
                        U2TxBuf >>= 1;
                      break;
              
                    }
                  }
                } 
               #endif
 185   1        
 186   1      
 187   1      /*模拟 UART3函数*/  
 188   1        // Rx
 189   1        if(U3RxPtr < U3RxBuff_MAXSIZE)
 190   1        {
 191   2          if(U3RxBitCount)
 192   2          {
 193   3            if(!--U3RxRate)
 194   3            {
 195   4              //用两个判断 U2RxBitCount==9,此处是延时一个停止位
 196   4              if(U3RxBitCount == 9)
 197   4              {
 198   5                U3RxBitCount = 0;   //stop Rxing
 199   5                U3RxBuffer[U3RxPtr++] = U3RxBuf;
 200   5                U3RxBuf = 0;
 201   5                IsU3RxBusy = 0;
 202   5                
 203   5              }
 204   4              else
 205   4              {
 206   5                U3RxRate = U3RxRate_bk;
 207   5                if(U3RxPin)
 208   5                {
 209   6                    U3RxBuf |= (1 << 7);
 210   6                }
 211   5                else
 212   5                { 
 213   6                    U3RxBuf &= ~(1 << 7);
 214   6                }
 215   5                
 216   5                U3RxBitCount++;
 217   5                if(U3RxBitCount == 9)
 218   5                {
 219   6                    return;
 220   6                }
 221   5                U3RxBuf >>= 1;          
 222   5              }
 223   4            }
 224   3          }
 225   2          else
 226   2          {
 227   3            if(!U3RxPin)
 228   3            {
 229   4              U3RxBitCount = 1;   //start Rx
 230   4              U3RxRate = U3RxRate_bk + 1;
 231   4              IsU3RxBusy = 1;
 232   4            }
 233   3          }  
 234   2        }
 235   1      
 236   1        
 237   1       
C51 COMPILER V9.52.0.0   SOFT_UART_1                                                       01/24/2018 16:50:50 PAGE 5   

 238   1        
 239   1        //to initiate a Tx, just write the U8 data to U2TxBuf,and set U2TxBitCount = 10 ,U2TxRate set to 3
 240   1        //first check if it's Txing (if U2TxBitCount != 0), 
 241   1      
 242   1        
 243   1        if(U3TxBitCount){
 244   2          if(!--U3TxRate){
 245   3            U3TxRate = U3TxRate_bk;
 246   3            //
 247   3            switch(U3TxBitCount --){
 248   4              case 1:   //Stop bit; send next byte
 249   4                U3TxPin = 1;
 250   4                if(U3TxPtr != U3LdPtr){
 251   5                  U3TxBuf = U3TxBuffer[U3TxPtr ++];
 252   5                  U3TxBitCount = 10;
 253   5                }
 254   4                else{
 255   5                  U3TxPtr = 0;
 256   5                  U3LdPtr = 0;
 257   5                  IsU3TxBusy = 0;
 258   5                }
 259   4              break;
 260   4      
 261   4              case 10:  //Start bit
 262   4                IsU3TxBusy = 1;
 263   4                U3TxPin = 0;
 264   4                if(U3TxPtr == 0)
 265   4                {
 266   5                  U3TxBuf = U3TxBuffer[U3TxPtr ++];
 267   5                }
 268   4              break;
 269   4              
 270   4              default:
 271   4                U3TxPin = U3TxBuf & 0x01;
 272   4                U3TxBuf >>= 1;
 273   4              break;
 274   4      
 275   4            }
 276   3          }
 277   2        }   
 278   1        
 279   1        
 280   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    323    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
