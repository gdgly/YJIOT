/**
******************************************************************************
* @file    user_downstream.c
* @author  herolizhen
* @version V1.0.0
* @date    14-May-2015
* @brief   user main functons in user_main thread.
******************************************************************************
*/
#include "mico.h"
#include "user_downstream.h"
#include "fog_v2_include.h"
#include "micokit_ext.h"
#include "user_charge.h"
#include "user_upstream.h"

#define FOG_V2_RECV_BUFF_LEN 100

extern bool get_wifi_status(void);

/* Handle user message from cloud
 * Receive msg from cloud && do hardware operation, like rgbled
 */
void user_downstream_thread(mico_thread_arg_t arg)
{
  static char last_ordno[50] = {0};
  
  char ordno[50] = {0};
  
  OSStatus err = kUnknownErr;

  char *recv_msg = NULL;
  //char jons_data[100] = {0};
  //unsigned int recv_msg_length = 0;
  //int i ,j = 0;
  int temp_charge_time = -1;
  int charge_type = -1;
  int charge_status = 0;
  
  json_object *recv_json_object = NULL;
  
  mico_Context_t *mico_context = (mico_Context_t *)arg;
  require(mico_context, exit);
  recv_msg = malloc( FOG_V2_RECV_BUFF_LEN );
  require( recv_msg != NULL, exit );
  while(1) {
    memset(recv_msg, 0, FOG_V2_RECV_BUFF_LEN);
    
    //memset(jons_data, 0, sizeof(jons_data));
    //recv_msg_length = 0;
    
    mico_thread_msleep(200);
    
    // check fogcloud connect status
    if(get_wifi_status() == false || fog_v2_is_https_connect() == false) {
      continue;
    }
    err = fog_v2_device_recv_command( recv_msg, FOG_V2_RECV_BUFF_LEN, MICO_NEVER_TIMEOUT );
    
    //err = MiCOFogCloudMsgRecv(app_context, &recv_msg, 100);
    if(kNoErr == err) {
      // debug log in MICO dubug uart
      
      user_downstream_log("user_downstream_thread recv:%s", recv_msg);
      
      
      /*
      if(*recv_msg != 0 && *(recv_msg+1) != 0){
            //user_downstream_log("Cloud => Module: %s",recv_msg);
          //user_downstream_log("user_downstream_thread recv:%s", recv_msg);
        
          if(*(recv_msg + 10) == '\\' && strncmp(recv_msg + 2,"data",4) == 0)
          {
              recv_msg_length = strlen(recv_msg);
              printf("recv_msg_length = %d\n",recv_msg_length);
          
              strcpy(jons_data,recv_msg + 9);
          
              jons_data[strlen(jons_data) -2] = '\0';
          
              printf("jons_data:%s",jons_data);
          
              i = 0;
              j = 0;
              while(*(jons_data + i) != '\0')
              {
                  if(*(jons_data + i) == '\\')
                  {
                      j = i;
                      while(*(jons_data + j) != '\0')
                      {
                        *(jons_data + j) = *(jons_data + j + 1);
                        j += 1;
                      }             
                  }
              
                  i += 1;

              }
                 
              printf("jons_data:%s\n",jons_data);            
          }
          else 
          {
              strcpy(jons_data,recv_msg);
              //jons_data[strlen(jons_data) -2] = '\0';
          }         
      }
      */
     
      
      
      // parse json data from the msg, get led control value
      //recv_json_object = json_tokener_parse((const char*)(jons_data));
      recv_json_object = json_tokener_parse((const char*)(recv_msg));
      if (NULL != recv_json_object) {
        int key_value = 0;
        json_object_object_foreach(recv_json_object, key, val)
        {
            //计费功能设置
          if(!strcmp(key, "ORDERNO"))
          {           
              memset(ordno,0,sizeof(ordno));   
              strcpy(ordno,json_object_get_string(val));
              user_downstream_log("ordno:%s", ordno);
          }
          else
          {
            key_value = json_object_get_int(val);        
            if(!strcmp(key, "FA")) {
              execute_fan_val(key_value);
            }
            else if(!strcmp(key, "UV")) {
              execute_UV_val(key_value);
            }
            else if(!strcmp(key, "NI")) {
              execute_negative_val(key_value);
            }
            else if(!strcmp(key, "DR")) {
              upload_door_data(key_value,NULL);
              if(key_value == 1)
              {
                //user_downstream_log("open door");
                execute_door_val(key_value);
              }             
            }
            else if(!strcmp(key, "AF")) {
              execute_fan_status(key_value);
            }
            else if(!strcmp(key, "EP")) {
            //系统设备风机 UV等关闭，待机和打开的控制
              user_downstream_log("download key: EP,value:%d",key_value);
              execute_EP_val(key_value);
            }
            else if(!strcmp(key, "SM")) {
              //共享模式不支持自动模式
              execute_SM_val(key_value);
            }   
            else if(!strcmp(key, "ER"))
            {
              charge_flash_erase(LEFT_TIME_ADDR_BASE,RECORD_ADDR_BASE + LEFT_TIME_MAX_OFFSET);
              stop_charge_mode();
            }
            if(!strcmp(key, "CHIPS")) {
              if(key_value >= 0)
              {
                temp_charge_time = key_value;
              }
              
            }
            if(!strcmp(key, "TYPE")) {
              charge_type = key_value;
            }
            if(!strcmp(key, "STATUS")) {
              charge_status = key_value;
            }
          }
         

        }
        
        
        if(strcmp(ordno,last_ordno) != 0 && charge_status == 1)
        {
          if(charge_type != -1 && temp_charge_time != -1)
          {    
            //控制蜂鸣器响一声
            charge_beep();
            
            updata_charge_timedata(ordno,(char)charge_type,(unsigned long)temp_charge_time);
            charge_type = -1;
            temp_charge_time = -1;
            charge_status = 0;
          
            memset(last_ordno,0,sizeof(last_ordno));
            strcpy(last_ordno,ordno);
          }        
        }

      }
      else {
        user_downstream_log("Do not get date from fogcloud!");
      }
    }

   // free memory of json object
    if(recv_json_object != NULL)
    {
      json_object_put(recv_json_object);
      recv_json_object = NULL;
    }

  }
exit:
  if(recv_json_object != NULL)
  {
    json_object_put(recv_json_object);
    recv_json_object = NULL;
  }
  if(recv_msg != NULL)
  {
    free(recv_msg);
    recv_msg = NULL;
  }

  user_downstream_log("ERROR: user_downstream_thread exit with err=%d", err);
}
