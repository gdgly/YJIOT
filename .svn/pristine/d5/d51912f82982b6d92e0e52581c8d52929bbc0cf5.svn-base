C51 COMPILER V9.52.0.0   CHARGE                                                            12/21/2017 11:02:15 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE CHARGE
OBJECT MODULE PLACED IN .\Objects\charge.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\charge\charge.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\project;.\
                    -USER\BUZZER;.\USER\charge;.\USER\common;.\USER\DC_MOTOR;.\USER\EEPROM;.\USER\EXINT;.\USER\IIC;.\USER\inc;.\USER\ION;.\US
                    -ER\M26;.\USER\PWM;.\USER\Sensor;.\USER\step_motor;.\USER\SYS_RUN;.\USER\timer;.\USER\TM1620;.\USER\touch_key;.\USER\UART
                    -;.\USER\UV;.\USER\LVI) DEBUG OBJECTEXTEND PRINT(.\Listings\charge.lst) TABS(2) OBJECT(.\Objects\charge.obj)

line level    source

   1          #include <stdio.h>
   2          #include <string.h>
   3          #include "charge.h"
   4          #include "global.h"
   5          #include "timer.h"
   6          #include "wifi_uart.h"
   7          #include "common.h"
   8          #include "debug_uart.h"
   9          #include "touch_key.h"
  10          #include "sys_run.h"
  11          #include "EEPROM.h"
  12          #include "M26.h"
  13          
  14          /*flash中存储方式大端法
  15          charge_info.lefttime.l_time = 2，则 charge_info.lefttime.c_time[0] = 0,charge_info.lefttime.c_time[1] = 0,
  16          charge_info.lefttime.c_time[2] = 0,charge_info.lefttime.c_time[3] = 2
  17          
  18          */
  19          
  20          Charge_Typedef charge_info;
  21          
  22          extern M26_Cmd_Typedef m26_cmd_info;
  23          
  24          #define CHARGE_INFO_LENGTH   5
  25          
  26          
  27          void charge_init(void)
  28          {
  29   1          //unsigned char i = 0; 
  30   1          unsigned char readbuff[10] ={0};
  31   1          unsigned int eeprom_addr = 0;
  32   1          
  33   1          eeprom_addr = EEPROM_START_ADDR | 0x00;
  34   1        
  35   1          mymemset(readbuff,0,sizeof(readbuff));
  36   1          EEPROM_Read_Bytes(readbuff,eeprom_addr,CHARGE_INFO_LENGTH);
  37   1        
  38   1      //    mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  39   1      //    sprintf(m26_cmd_info.sendtring,"read data:%d %d %d %d %d\r\n",(unsigned int)m26_cmd_info.cmd[0],(uns
             -igned int)m26_cmd_info.cmd[1],
  40   1      //             (unsigned int)m26_cmd_info.cmd[2],(unsigned int)m26_cmd_info.cmd[3],(unsigned int)m26_cmd_i
             -nfo.cmd[4]);
  41   1      //    DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
  42   1          
  43   1      //    mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  44   1      //    sprintf(m26_cmd_info.sendtring,"read data:%x %x %x %x %x\r\n",(unsigned int)readbuff[0],(unsigned in
             -t)readbuff[1],
  45   1      //             (unsigned int)readbuff[2],(unsigned int)readbuff[3],(unsigned int)readbuff[4]);
  46   1      //    DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
  47   1          
  48   1      
  49   1          
C51 COMPILER V9.52.0.0   CHARGE                                                            12/21/2017 11:02:15 PAGE 2   

  50   1          if(readbuff[0] > 1)
  51   1          {
  52   2              //EEPROM_Page_Erase(EEPROM_START_ADDR);
  53   2              //mymemset(readbuff,0,sizeof(readbuff));
  54   2              //EEPROM_Read_Bytes(readbuff,eeprom_addr,CHARGE_INFO_LENGTH);
  55   2            
  56   2      //     mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  57   2      //    sprintf(m26_cmd_info.sendtring,"read data:%x %x %x %x %x\r\n",(unsigned int)readbuff[0],(unsigned in
             -t)readbuff[1],
  58   2      //             (unsigned int)readbuff[2],(unsigned int)readbuff[3],(unsigned int)readbuff[4]);
  59   2      //    DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
  60   2          }
  61   1            
  62   1          if(readbuff[0] == 0xFF)
  63   1          {
  64   2            
  65   2              mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  66   2              sprintf(m26_cmd_info.sendtring,"way0\r\n");
  67   2              DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
  68   2              //此种情况是第一次上电，设置为默认形式的家用机
  69   2              //防止该page有的数据不是0xFF，所以执行一次擦除操作
  70   2              EEPROM_Page_Erase(EEPROM_START_ADDR);
  71   2                
  72   2              mymemset(readbuff,0,sizeof(readbuff));
  73   2              EEPROM_Write_Bytes(readbuff,EEPROM_START_ADDR,CHARGE_INFO_LENGTH);
  74   2              //EEPROM_Write_Bytes(readbuff,EEPROM_START_ADDR,5);
  75   2              //EEPROM_Byte_Program(EEPROM_START_ADDR,0);
  76   2            
  77   2          mymemset(readbuff,3,sizeof(readbuff));
  78   2          EEPROM_Read_Bytes(readbuff,(unsigned int)(EEPROM_START_ADDR),10);
  79   2      //    readbuff[0] = EEPROM_Byte_Read(EEPROM_START_ADDR);
  80   2      //    readbuff[1] = EEPROM_Byte_Read(EEPROM_START_ADDR + 1);
  81   2          mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  82   2          sprintf(m26_cmd_info.sendtring,"read data:%x %x %x %x %x %x\r\n",(unsigned int)readbuff[0],(unsigned i
             -nt)readbuff[1],
  83   2                   (unsigned int)readbuff[2],(unsigned int)readbuff[3],(unsigned int)readbuff[4],(unsigned int)r
             -eadbuff[5]);
  84   2          DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
  85   2                
  86   2              charge_info.IsChargeType = 0;
  87   2              charge_info.lefttime.l_time = 0;
  88   2              charge_info.eeprom_next_write_addr = eeprom_addr + CHARGE_INFO_LENGTH;
  89   2                
  90   2              goto exit;
  91   2                 
  92   2          }
  93   1          else
  94   1          {
  95   2              eeprom_addr = eeprom_addr + CHARGE_INFO_LENGTH;
  96   2            
  97   2              do{
  98   3                    mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  99   3                    sprintf(m26_cmd_info.sendtring,"way3\r\n");
 100   3                    DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 101   3                    //每次读取2组数据，10个字节
 102   3                    mymemset(readbuff,0,sizeof(readbuff));
 103   3                    //EEPROM_Read_Bytes(readbuff,eeprom_addr,(CHARGE_INFO_LENGTH * 2));
 104   3                    EEPROM_Read_Bytes(readbuff,eeprom_addr,10);
 105   3            
 106   3                    if(readbuff[0] == 0xFF || readbuff[5] == 0xFF)
 107   3                    {               
 108   4                        if(readbuff[0] == 0xFF)
C51 COMPILER V9.52.0.0   CHARGE                                                            12/21/2017 11:02:15 PAGE 3   

 109   4                        {
 110   5                            mymemset(readbuff,0,sizeof(readbuff));
 111   5                            EEPROM_Read_Bytes(readbuff,(eeprom_addr - CHARGE_INFO_LENGTH),CHARGE_INFO_LENGTH);  
 112   5                
 113   5                            charge_info.eeprom_next_write_addr = eeprom_addr;
 114   5                          
 115   5                            mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 116   5                            sprintf(m26_cmd_info.sendtring,"way1\r\n");
 117   5                            DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 118   5                        }
 119   4                        else
 120   4                        {
 121   5                            charge_info.eeprom_next_write_addr = eeprom_addr + CHARGE_INFO_LENGTH;
 122   5                          
 123   5                            mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 124   5                            sprintf(m26_cmd_info.sendtring,"way2\r\n");
 125   5                            DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 126   5                        }                    
 127   4               
 128   4                        charge_info.IsChargeType = readbuff[0];
 129   4                        charge_info.lefttime.c_time[0] = readbuff[4];
 130   4                        charge_info.lefttime.c_time[1] = readbuff[3];
 131   4                        charge_info.lefttime.c_time[2] = readbuff[2];
 132   4                        charge_info.lefttime.c_time[3] = readbuff[1];
 133   4                                  
 134   4                        goto exit;         
 135   4                    }
 136   3                    
 137   3                    if(eeprom_addr < (EEPROM_END_ADDR - 9))
 138   3                    {
 139   4                        eeprom_addr += (CHARGE_INFO_LENGTH * 2);
 140   4                    }
 141   3                    else if(eeprom_addr == (EEPROM_END_ADDR - 9))              
 142   3                    {
 143   4                        //此种情况是有效数据是最后一组数据
 144   4                        charge_info.IsChargeType = readbuff[5];
 145   4                        charge_info.lefttime.c_time[0] = readbuff[9];
 146   4                        charge_info.lefttime.c_time[1] = readbuff[8];
 147   4                        charge_info.lefttime.c_time[2] = readbuff[7];
 148   4                        charge_info.lefttime.c_time[3] = readbuff[6];
 149   4                        //如果在执行flash写操作时，如果 charge_info.eeprom_write_addr == EEPROM_START_ADDR时，该
             -页被写满了，则需要先擦除，然后再从起始地址写
 150   4                        charge_info.eeprom_next_write_addr = EEPROM_START_ADDR;
 151   4                      
 152   4                        mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 153   4                        sprintf(m26_cmd_info.sendtring,"page full,re-write\r\n");
 154   4                        DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 155   4                      
 156   4                        goto exit;
 157   4                    }
 158   3                    else
 159   3                    {
 160   4                        //肯定出错了
 161   4                        mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 162   4                        sprintf(m26_cmd_info.sendtring,"eeprom addr out of range\r\n");
 163   4                        DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 164   4                      
 165   4                        charge_info.IsChargeType = 1;
 166   4                        charge_info.lefttime.l_time = 0;
 167   4                      
 168   4                        charge_info.eeprom_next_write_addr = EEPROM_START_ADDR;
 169   4           
C51 COMPILER V9.52.0.0   CHARGE                                                            12/21/2017 11:02:15 PAGE 4   

 170   4                        goto exit;
 171   4                    }             
 172   3          
 173   3              }while(eeprom_addr < EEPROM_END_ADDR);    
 174   2          }
 175   1      exit:
 176   1      
 177   1          charge_info.next_1min_time = get_sys_stime() + (MIN_TO_S | 0x00);
 178   1          
 179   1          mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 180   1          sprintf(m26_cmd_info.sendtring,"find addr:%x\r\n",(unsigned int)charge_info.eeprom_next_write_addr);
 181   1          DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 182   1          
 183   1          mymemset(readbuff,0,sizeof(readbuff));
 184   1          EEPROM_Read_Bytes(readbuff,(unsigned int)(charge_info.eeprom_next_write_addr-5),10);
 185   1          mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 186   1          sprintf(m26_cmd_info.sendtring,"read data:%x %x %x %x %x %x\r\n",(unsigned int)readbuff[0],(unsigned i
             -nt)readbuff[1],
 187   1                   (unsigned int)readbuff[2],(unsigned int)readbuff[3],(unsigned int)readbuff[4],(unsigned int)r
             -eadbuff[5]);
 188   1          DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 189   1          
 190   1          mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 191   1          sprintf(m26_cmd_info.sendtring,"type:%d,time:%d\r\n",(unsigned int)charge_info.IsChargeType,(unsigned 
             -int)charge_info.lefttime.l_time);
 192   1          DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 193   1          
 194   1          
 195   1      }
 196          
 197          
 198          void charge_lefttime_flash_write(void)
 199          {
 200   1          unsigned char i = 0;
 201   1        
 202   1          if(charge_info.eeprom_next_write_addr == EEPROM_START_ADDR)
 203   1          {
 204   2              EEPROM_Page_Erase(EEPROM_START_ADDR);
 205   2          }
 206   1          
 207   1          for(i = 0;i < CHARGE_INFO_LENGTH;i++)
 208   1          {
 209   2              if(i == 0)
 210   2              {
 211   3                  EEPROM_Byte_Program(charge_info.eeprom_next_write_addr,(unsigned char)charge_info.IsChargeType
             -);
 212   3              }
 213   2              else
 214   2              {
 215   3                  EEPROM_Byte_Program(charge_info.eeprom_next_write_addr + i,charge_info.lefttime.c_time[4-i]);
 216   3              }
 217   2          }
 218   1          
 219   1          if(charge_info.eeprom_next_write_addr > (EEPROM_END_ADDR - CHARGE_INFO_LENGTH))
 220   1          {
 221   2              charge_info.eeprom_next_write_addr = EEPROM_START_ADDR;
 222   2          }
 223   1          else
 224   1          {
 225   2              charge_info.eeprom_next_write_addr += CHARGE_INFO_LENGTH;
 226   2          }
 227   1      }
C51 COMPILER V9.52.0.0   CHARGE                                                            12/21/2017 11:02:15 PAGE 5   

 228          
 229          
 230          void charge_lefttime_count(void)
 231          {
 232   1          unsigned char readbuff[5] = {0};
 233   1          if(charge_info.IsChargeType == 0)
 234   1          {
 235   2              return;
 236   2          }
 237   1          
 238   1          if(charge_info.lefttime.l_time == 0)
 239   1          {
 240   2              return;
 241   2          }
 242   1          
 243   1          nowtime_s = get_sys_stime();   
 244   1          //防止时间溢出，正常情况下此处不会溢出
 245   1          if(nowtime_s < (MIN_TO_S | 0x00) && charge_info.next_1min_time >= 0xF0000000)
 246   1          {
 247   2              charge_info.next_1min_time = nowtime_s + (MIN_TO_S | 0x00);
 248   2          }
 249   1          if(nowtime_s >= charge_info.next_1min_time)
 250   1          {
 251   2              charge_info.lefttime.l_time -= 1;
 252   2              charge_info.next_1min_time += (MIN_TO_S | 0x00);
 253   2            
 254   2              if(charge_info.lefttime.l_time == 0)
 255   2              {
 256   3                  charge_lefttime_flash_write();
 257   3              }
 258   2              
 259   2              mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 260   2              sprintf(m26_cmd_info.sendtring,"lefttime:%d\r\n",(unsigned int)(charge_info.lefttime.l_time));
 261   2              DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 262   2            
 263   2      //        charge_lefttime_flash_write();
 264   2      //        mymemset(readbuff,0,sizeof(readbuff));
 265   2      //        EEPROM_Read_Bytes(readbuff,(unsigned int)(charge_info.eeprom_next_write_addr-5),5);
 266   2      //        mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 267   2      //        sprintf(m26_cmd_info.sendtring,"read data:%x %x %x %x %x\r\n",(unsigned int)readbuff[0],(unsigne
             -d int)readbuff[1],
 268   2      //             (unsigned int)readbuff[2],(unsigned int)readbuff[3],(unsigned int)readbuff[4]);
 269   2      //        DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 270   2          }    
 271   1      }
 272          
 273          
 274          
 275          
 276          
 277          
 278          
 279          
 280          
 281          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1874    ----
   CONSTANT SIZE    =    168    ----
   XDATA SIZE       =     15      18
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.52.0.0   CHARGE                                                            12/21/2017 11:02:15 PAGE 6   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
