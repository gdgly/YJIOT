C51 COMPILER V9.52.0.0   EEPROM                                                            12/21/2017 11:02:15 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\Objects\EEPROM.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\EEPROM\EEPROM.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\project;.\
                    -USER\BUZZER;.\USER\charge;.\USER\common;.\USER\DC_MOTOR;.\USER\EEPROM;.\USER\EXINT;.\USER\IIC;.\USER\inc;.\USER\ION;.\US
                    -ER\M26;.\USER\PWM;.\USER\Sensor;.\USER\step_motor;.\USER\SYS_RUN;.\USER\timer;.\USER\TM1620;.\USER\touch_key;.\USER\UART
                    -;.\USER\UV;.\USER\LVI) DEBUG OBJECTEXTEND PRINT(.\Listings\EEPROM.lst) TABS(2) OBJECT(.\Objects\EEPROM.obj)

line level    source

   1          #include <stdio.h>
   2          #include <string.h>
   3          #include "OB39R32T1.h"
   4          #include <absacc.h>    /* Include Macro Definitions */
   5          #include "EEPROM.h"
   6          #include "global.h"
   7          #include "common.h"
   8          #include "debug_uart.h"
   9          #include "M26.h"
  10          
  11          
  12          extern M26_Cmd_Typedef m26_cmd_info;
  13          
  14          /*ISPFC.ISPF[2:0]*/
  15          #define d_Command_Byte_Program  0
  16          #define d_Command_Page_Erase    2
  17          #define d_EEPROM_Start_Addr     0x7C
  18          
  19          //====================================================================
  20          //#define d_DATALEN   64              // idata limit:1~128
  21          //unsigned char idata buf[d_DATALEN]; // idata limit:1~128
  22          
  23          void Software_Reset(void)
  24          {
  25   1          EA    = 0;
  26   1          TAKEY = 0x55;
  27   1          TAKEY = 0xAA;
  28   1          TAKEY = 0x5A;
  29   1          SWRES = 0xFF;
  30   1      }
  31          
  32          void Check_ISPFAH(void)
  33          {
  34   1          if (ISPFAH < d_EEPROM_Start_Addr)
  35   1              Software_Reset();
  36   1      }
  37          
  38          void EEPROM_Enable(void)
  39          {
  40   1          EA     = 0;
  41   1          TAKEY  = 0x55;
  42   1          TAKEY  = 0xAA;
  43   1          TAKEY  = 0x5A;
  44   1          IFCON |= 0x01;    // ISPE=1, Enable ISP function
  45   1          EA     = 1;
  46   1      }
  47          
  48          void EEPROM_Disable(void)
  49          {
  50   1          EA     = 0;
  51   1          TAKEY  = 0x55;
  52   1          TAKEY  = 0xAA;
C51 COMPILER V9.52.0.0   EEPROM                                                            12/21/2017 11:02:15 PAGE 2   

  53   1          TAKEY  = 0x5A;
  54   1          IFCON &= 0xFE;    // ISPE=0, Disable  ISP function
  55   1          EA     = 1;
  56   1      }
  57          
  58          void EEPROM_Byte_Program(unsigned int Addr, unsigned char Data)
  59          {
  60   1          EEPROM_Enable();
  61   1          ISPFD  = Data;
  62   1          ISPFAH = (Addr/256);
  63   1          ISPFAL = (Addr%256);
  64   1          if (ISPFAH >= d_EEPROM_Start_Addr)
  65   1              ISPFC = d_Command_Byte_Program;
  66   1          else
  67   1              //Software_Reset();
  68   1              goto exit;
  69   1          
  70   1      exit:
  71   1          EEPROM_Disable();
  72   1      }
  73          
  74          void EEPROM_Page_Erase(unsigned int Addr)    //erase 1K byte
  75          {
  76   1          EEPROM_Enable();
  77   1          ISPFAH = (Addr/256);
  78   1          ISPFAL = (Addr%256);
  79   1          if (ISPFAH >= d_EEPROM_Start_Addr)
  80   1              ISPFC = d_Command_Page_Erase;
  81   1          else
  82   1              //Software_Reset();
  83   1              goto exit;
  84   1          
  85   1      exit:
  86   1          EEPROM_Disable();
  87   1      }
  88          
  89          void EEPROM_Sector_Program(unsigned int Addr_start, unsigned int Addr_end, unsigned char Data)
  90          {
  91   1          unsigned int i;
  92   1          for (i = Addr_start; i <= Addr_end; i++)
  93   1          {
  94   2              EEPROM_Byte_Program(i, Data);
  95   2          }
  96   1      }
  97          
  98          unsigned char EEPROM_Byte_Read(unsigned int Addr)
  99          {
 100   1          return CBYTE[Addr];    //The range of valid index values for this macro is 0-255
 101   1      }
 102          
 103          
 104          void EEPROM_Read_Bytes(unsigned char *buff,unsigned int Addr,unsigned char length)
 105          {
 106   1          unsigned char i = 0;
 107   1          if(buff == NULL)
 108   1          {
 109   2              return;
 110   2          }
 111   1          
 112   1          if(Addr < EEPROM_START_ADDR || Addr > EEPROM_END_ADDR)
 113   1          {
 114   2              return;
C51 COMPILER V9.52.0.0   EEPROM                                                            12/21/2017 11:02:15 PAGE 3   

 115   2          }
 116   1          
 117   1      //    mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 118   1      //    sprintf(m26_cmd_info.sendtring,"EEPROM_Read_Bytes step0\r\n");
 119   1      //    DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 120   1          
 121   1          for(i = 0;i < length;i ++)
 122   1          {
 123   2              buff[i] = EEPROM_Byte_Read(Addr + i);
 124   2          }
 125   1      }
 126          
 127          
 128          void EEPROM_Write_Bytes(unsigned char *buff,unsigned int Addr,unsigned char length)
 129          {
 130   1          unsigned char i = 0;
 131   1          unsigned int eeprom_addr = 0;
 132   1          if(buff == NULL)
 133   1          {
 134   2      //        mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 135   2      //        sprintf(m26_cmd_info.sendtring,"EEPROM_Write_Bytes step0\r\n");
 136   2      //        DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 137   2              return;
 138   2          }
 139   1          
 140   1          if(Addr < EEPROM_START_ADDR || Addr > EEPROM_END_ADDR)
 141   1          {
 142   2      //        mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 143   2      //        sprintf(m26_cmd_info.sendtring,"EEPROM_Write_Bytes step2\r\n");
 144   2      //        DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 145   2              return;
 146   2          }
 147   1          
 148   1      //    mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 149   1      //    sprintf(m26_cmd_info.sendtring,"write addr:%x,length:%d\r\n",(unsigned int)Addr,(unsigned int)length
             -);
 150   1      //    DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 151   1          
 152   1          eeprom_addr = Addr;
 153   1          
 154   1          for(i = 0;i < length;i++)
 155   1          {
 156   2              EEPROM_Byte_Program((eeprom_addr + i),buff[i]);
 157   2          }
 158   1      }
 159          
 160          
 161          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    412    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
