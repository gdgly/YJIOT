C51 COMPILER V9.52.0.0   USER_TIMER                                                        01/22/2018 10:28:15 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE USER_TIMER
OBJECT MODULE PLACED IN .\Objects\user_timer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\user_timer\user_timer.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\pr
                    -oject;.\USER\BUZZER;.\USER\DC_MOTOR;.\USER\EXINT;.\USER\IIC;.\USER\inc;.\USER\ION;.\USER\PWM;.\USER\step_motor;.\USER\SY
                    -S_RUN;.\USER\timer;.\USER\TM1620;.\USER\touch_key;.\USER\UART;.\USER\UV;.\USER\Sensor;.\USER\user_timer) DEBUG OBJECTEXT
                    -END PRINT(.\Listings\user_timer.lst) TABS(2) OBJECT(.\Objects\user_timer.obj)

line level    source

   1          #include <stdio.h>
   2          #include <string.h>
   3          #include "user_timer.h"
   4          #include "global.h"
   5          #include "timer.h"
   6          #include "wifi_uart.h"
   7          //#include "common.h"
   8          #include "debug_uart.h"
   9          #include "touch_key.h"
  10          #include "sys_run.h"
  11          #include "TM1620.h"
  12          
  13          user_timer_t user_timer_info;
  14          
  15          void user_timer_init(void)
  16          {
  17   1          user_timer_info.user_timer_start = 0;
  18   1          user_timer_info.timer_state = 0;
  19   1          user_timer_info.set_time = 0;
  20   1          user_timer_info.left_time = 0;
  21   1      }
  22          
  23          void user_timer_count(void)
  24          {
  25   1         const unsigned long min_to_ms = 60000;
  26   1         static unsigned long time_triger = 0;
  27   1         unsigned long nowtime = 0;
  28   1         unsigned char debug_buff[30] = {0};
  29   1        
  30   1         nowtime = get_sys_mstime();
  31   1         if(nowtime <= 0xF0000000 && time_triger > 0xF0000000 )
  32   1         {
  33   2             //·ÀÖ¹Ê±¼äÒç³ö
  34   2             time_triger = nowtime + min_to_ms;
  35   2         }
  36   1         
  37   1         if(user_timer_info.user_timer_start == 1)
  38   1         {
  39   2             //time_triger = nowtime + (MIN_TO_MS | 0x00);
  40   2             time_triger = nowtime + min_to_ms;
  41   2             user_timer_info.user_timer_start = 0;
  42   2         }
  43   1         
  44   1         if(nowtime >= time_triger)
  45   1         {
  46   2            if(user_timer_info.left_time > 0)
  47   2            {
  48   3                user_timer_info.left_time -= 1;
  49   3              
  50   3      //          mymemset(debug_buff,0,sizeof(debug_buff));
  51   3      //          sprintf(debug_buff,"lefttime:%d\r\n",(unsigned int)user_timer_info.left_time);
  52   3      //          DEBUG_Uart_Sendbytes(debug_buff,strlen(debug_buff)); 
C51 COMPILER V9.52.0.0   USER_TIMER                                                        01/22/2018 10:28:15 PAGE 2   

  53   3            }
  54   2            if(user_timer_info.left_time == 0)
  55   2            {
  56   3                if(sys_mode == RUNNING)
  57   3                {
  58   4                    sys_stop(); 
  59   4                }
  60   3            }
  61   2            //time_triger = time_triger + (MIN_TO_MS | 0x00);
  62   2            time_triger = time_triger + min_to_ms;
  63   2         }
  64   1      }
  65          
  66          
  67          void stop_user_timer(void)
  68          {
  69   1          user_timer_info.user_timer_start = 0;
  70   1          user_timer_info.timer_state = 0;
  71   1          user_timer_info.set_time = 0;
  72   1          user_timer_info.left_time = 0;
  73   1        
  74   1          if(user_timer_type == USER_TIMER_2H)
  75   1          {
  76   2              TM1620_LED_Control(LED_TIMER_2H,LED_OFF);
  77   2          }
  78   1          else if(user_timer_type == USER_TIMER_4H)
  79   1          {
  80   2              TM1620_LED_Control(LED_TIMER_4H,LED_OFF);
  81   2          }
  82   1        
  83   1          user_timer_type = USER_TIMER_NONE;
  84   1      }
  85          
  86          void set_user_timer(unsigned char timer_type)
  87          {
  88   1          if(timer_type > USER_TIMER_4H || timer_type < 0)
  89   1          {
  90   2              return;
  91   2          }
  92   1          
  93   1          if(timer_type == USER_TIMER_NONE)
  94   1          {
  95   2              stop_user_timer();
  96   2          }
  97   1          else
  98   1          {
  99   2              user_timer_info.user_timer_start = 1;
 100   2              user_timer_info.timer_state = 1;
 101   2            
 102   2              if(timer_type == USER_TIMER_2H)
 103   2              {
 104   3                  user_timer_info.set_time = 120;
 105   3                  TM1620_LED_Control(LED_TIMER_2H,LED_ON);
 106   3              }
 107   2              else if(timer_type == USER_TIMER_4H)
 108   2              {
 109   3                  user_timer_info.set_time = 240;
 110   3                  TM1620_LED_Control(LED_TIMER_4H,LED_ON);
 111   3              }
 112   2              user_timer_info.left_time = user_timer_info.set_time;    
 113   2          }          
 114   1      }
C51 COMPILER V9.52.0.0   USER_TIMER                                                        01/22/2018 10:28:15 PAGE 3   

 115          
 116          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    473    ----
   CONSTANT SIZE    =     30    ----
   XDATA SIZE       =     10      39
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
