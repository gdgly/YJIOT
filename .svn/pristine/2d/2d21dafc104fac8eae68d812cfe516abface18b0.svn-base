C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         10/25/2017 13:17:54 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE TOUCH_KEY
OBJECT MODULE PLACED IN .\Objects\touch_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\touch_key\touch_key.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER\
                    -IIC;.\USER\UART;.\USER\TM1618;.\USER\Sensor;.\USER;.\USER\PWM;.\USER\DC_MOTOR;.\USER\timer;.\USER\inc;.\USER\EXINT;.\USE
                    -R\touch_key;.\USER\SYS_RUN;.\USER\step_motor;.\USER\BUZZER;.\USER\UART;.\USER\common;.\USER\lib;.\USER\UV;.\USER\ION;.\U
                    -SER\EEPROM;.\USER\TM1620;.\USER\charge) DEBUG OBJECTEXTEND PRINT(.\Listings\touch_key.lst) TABS(2) OBJECT(.\Objects\touc
                    -h_key.obj)

line level    source

   1          #include <stdio.h>
   2          #include "touch_key.h"
   3          #include "SOFT_IIC.h"
   4          #include "timer.h"
   5          #include "global.h"
   6          #include "debug_uart.h"
   7          #include "common.h"
   8          
   9          
  10          KEY_INFO_Typedef  key_info;
  11          
  12          
  13          #define KEY_IIC_DELAY_COUNT  10
  14          
  15          void key_i2c_delay(void)
  16          {
  17   1        int i = 0;
  18   1        for(i = 0;i < KEY_IIC_DELAY_COUNT;i++);
  19   1      }
  20          
  21          
  22          void Key_IIC_PinConifg(void)
  23          {
  24   1           
  25   1          KEY_IIC_PxM0 &= ~((1 << KEY_IIC_SDA_PORTBIT) | (1 << KEY_IIC_SCL_PORTBIT));
  26   1          KEY_IIC_PxM1 &= ~((1 << KEY_IIC_SDA_PORTBIT) | (1 << KEY_IIC_SCL_PORTBIT));
  27   1        
  28   1          KEY_IIC_SCL_PIN = 1;
  29   1          KEY_IIC_SDA_PIN = 1;
  30   1      }
  31          
  32          
  33          
  34          void Set_KEY_SDA_Pin_Mode(unsigned char mode)
  35          {
  36   1          if(mode == PIN_INPUT)
  37   1          {
  38   2              //PIN设置为输入时，PxM0对应的位置0，PxM1对应的位置1
  39   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SDA_PORTBIT);
  40   2              KEY_IIC_PxM1 |= (1 << KEY_IIC_SDA_PORTBIT);
  41   2          }
  42   1          else if(mode == PIN_OUTPUT)
  43   1          {      
  44   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SDA_PORTBIT);
  45   2              KEY_IIC_PxM1 &= ~(1 << KEY_IIC_SDA_PORTBIT);
  46   2          }
  47   1      }
  48            
  49          void Set_KEY_SCL_Pin_Mode(unsigned char mode)
  50          {
  51   1          if(mode == PIN_INPUT)
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         10/25/2017 13:17:54 PAGE 2   

  52   1          {
  53   2              //PIN设置为输入时，PxM0对应的位置0，PxM1对应的位置1
  54   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SCL_PORTBIT);
  55   2              KEY_IIC_PxM1 |= ((1 << KEY_IIC_SCL_PORTBIT));
  56   2          }
  57   1          else if(mode == PIN_OUTPUT)
  58   1          {      
  59   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SCL_PORTBIT);
  60   2              KEY_IIC_PxM1 &= ~(1 << KEY_IIC_SCL_PORTBIT);     
  61   2          }
  62   1      
  63   1      }
  64          
  65          
  66          void Key_IIC_SDA_1(void)
  67          {
  68   1          KEY_IIC_SDA_PIN = 1;
  69   1      }
  70          
  71          void Key_IIC_SDA_0(void)
  72          {
  73   1          KEY_IIC_SDA_PIN = 0;
  74   1      }
  75          
  76          void Key_IIC_SCL_1(void)
  77          {
  78   1          KEY_IIC_SCL_PIN = 1;
  79   1      }
  80          void Key_IIC_SCL_0(void)
  81          {
  82   1          KEY_IIC_SCL_PIN = 0;
  83   1      }
  84          
  85          
  86          unsigned char Key_IIC_SDA_READ(void)
  87          {
  88   1          return (KEY_IIC_SDA_PIN ? 1 : 0);
  89   1      }
  90          
  91          
  92          
  93          void Get_Key_Status(unsigned char *key_status)
  94          {
  95   1          const unsigned char readaddr = 0x17;
  96   1          unsigned char res = 1;
  97   1        
  98   1          IIC_Operations.IIC_NUM = TOUCH_KEY_IIC;
  99   1          IIC_Operations.Set_SDA_Pin_Mode = Set_KEY_SDA_Pin_Mode;
 100   1          IIC_Operations.Set_SCL_Pin_Mode = Set_KEY_SCL_Pin_Mode;
 101   1          IIC_Operations.i2c_delay = key_i2c_delay;
 102   1          IIC_Operations.SDA_1 = Key_IIC_SDA_1;
 103   1          IIC_Operations.SDA_0 = Key_IIC_SDA_0;
 104   1          IIC_Operations.SCL_1 = Key_IIC_SCL_1;
 105   1          IIC_Operations.SCL_0 = Key_IIC_SCL_0;
 106   1          IIC_Operations.I2C_SDA_READ = Key_IIC_SDA_READ;
 107   1        
 108   1          
 109   1          res = I2C_WriteBytes(OB39A08T1_ADDRESS,&readaddr,1);
 110   1          if(res == 0)
 111   1          {
 112   2              I2C_ReadBytes(OB39A08T1_ADDRESS,key_status,3);
 113   2          }
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         10/25/2017 13:17:54 PAGE 3   

 114   1          
 115   1      }
 116          
 117          unsigned char Scan_TouchPad(void)
 118          {
 119   1          static unsigned char wifi_key_count_times = 0;
 120   1          unsigned char whichkey = 0;
 121   1          unsigned char temp_status0,temp_status1 = 0;
 122   1          static unsigned char last_status0,last_status1 = 0;
 123   1        
 124   1          //unsigned char debug_buff[20] = {0};
 125   1        
 126   1          unsigned char key_status[3] = {0};
 127   1          
 128   1          //如果上电后检测到仓门坏了，则按键不起作用
 129   1          //如果仓门正在工作则按键不起作用
 130   1          if(IsStepMotorBusy)
 131   1          //if(IsStepMotorBusy || IsSysFault)
 132   1          {
 133   2              return 0xFF;
 134   2          }
 135   1          
 136   1          Get_Key_Status(key_status);
 137   1        
 138   1          temp_status0 = key_status[2];
 139   1          temp_status1 = key_status[1];
 140   1        
 141   1          //POWER按键和其他按键不能同时按下
 142   1          if((temp_status0 == 0 && temp_status1 == 0) || (temp_status0 != 0 && temp_status1 != 0))
 143   1          {
 144   2              last_status0 = 0;
 145   2              last_status1 = 0;
 146   2            
 147   2              wifi_key_count_times = 0;
 148   2      
 149   2              Clear_Touch_Info();
 150   2              return 0;
 151   2          }
 152   1          
 153   1          if(temp_status0 != 0)
 154   1          {
 155   2              if(temp_status0 != last_status0)
 156   2              {
 157   3                  key_info.IsCount = 1;
 158   3                  key_info.count_times = 0;
 159   3                  key_info.IsTouchedKey = 0;
 160   3                  key_info.WhichKey = KEY_NONE;
 161   3              }
 162   2          }
 163   1          
 164   1          if(temp_status1 != 0)
 165   1          {
 166   2              if(temp_status1 != last_status1)
 167   2              {
 168   3                  key_info.IsCount = 1;
 169   3                  key_info.count_times = 0;
 170   3                  key_info.IsTouchedKey = 0;
 171   3                  key_info.WhichKey = KEY_NONE;
 172   3              }
 173   2          }
 174   1          
 175   1          if(key_info.count_times >= (KEY_TOUCH_MS_TIMES * TIMER_BASE))
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         10/25/2017 13:17:54 PAGE 4   

 176   1          {
 177   2              //一个按键计数完毕后停止计数，防止一直按着一个按键不松开
 178   2              if(temp_status1 != KEY_WIFI_VALUE)
 179   2              {
 180   3                  key_info.IsCount = 0;
 181   3                  key_info.count_times = 0;
 182   3                
 183   3                  //如果不是按下wifi组合键，先把wifi计数清零
 184   3                  wifi_key_count_times = 0;
 185   3              }
 186   2              else
 187   2              {
 188   3                  //如果按下的是WIFI按键，则从0重新开始计数，直到检测到按下2秒钟以后再停止
 189   3                  key_info.count_times = 0;
 190   3              }
 191   2      
 192   2              
 193   2              if(temp_status0 != 0)
 194   2              {
 195   3                  if(temp_status0 == KEY_POWER_VALUE)
 196   3                  {
 197   4                      key_info.IsTouchedKey = 1;
 198   4                      key_info.WhichKey = KEY_POWER;
 199   4                  }
 200   3                  else
 201   3                  {
 202   4                      key_info.IsTouchedKey = 0;
 203   4                      key_info.WhichKey = KEY_NONE;
 204   4                  }
 205   3                  
 206   3                  wifi_key_count_times = 0;
 207   3              }
 208   2              
 209   2              if(temp_status1 != 0)
 210   2              {         
 211   3                  if(temp_status1 == KEY_SPEED_VALUE)
 212   3                  {
 213   4                      key_info.IsTouchedKey = 1;
 214   4                      key_info.WhichKey = KEY_SPEED;
 215   4                  }
 216   3                  else if(temp_status1 == KEY_TIMER_VALUE)
 217   3                  {
 218   4                      key_info.IsTouchedKey = 1;
 219   4                      key_info.WhichKey = KEY_TIMER;
 220   4                  }
 221   3                  else if(temp_status1 == KEY_MODE_VALUE)
 222   3                  {
 223   4                      key_info.IsTouchedKey = 1;
 224   4                      key_info.WhichKey = KEY_MODE;
 225   4                  }    
 226   3                  else if(temp_status1 == KEY_WIFI_VALUE)
 227   3                  {
 228   4                    
 229   4                      wifi_key_count_times += 1;
 230   4      //                mymemset(debug_buff,0,mystrlen(debug_buff));
 231   4      //                sprintf(debug_buff,"wifi_times:%d\n",(unsigned int)wifi_key_count_times);  
 232   4      //                DEBUG_Uart_Sendbytes(debug_buff,mystrlen(debug_buff));  
 233   4                    
 234   4                      if(wifi_key_count_times >= (2000 / KEY_TOUCH_MS_TIMES))
 235   4                      {
 236   5                          key_info.IsTouchedKey = 1;
 237   5                          key_info.WhichKey = KEY_WIFI;
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         10/25/2017 13:17:54 PAGE 5   

 238   5                        
 239   5                          //停止中断中的计数
 240   5                          key_info.IsCount = 0;
 241   5                          key_info.count_times = 0;
 242   5                          //此处wifi_key_count_times不清零，防止一直按着组合键不松开，松开按键后再清零
 243   5                      }
 244   4                    
 245   4                      
 246   4      //                key_info.IsTouchedKey = 1;
 247   4      //                key_info.WhichKey = KEY_WIFI;
 248   4      
 249   4                  }              
 250   3                  else
 251   3                  {
 252   4                      key_info.IsTouchedKey = 0;
 253   4                      key_info.WhichKey = KEY_NONE;            
 254   4                  }
 255   3                  
 256   3      
 257   3              }
 258   2                 
 259   2          }
 260   1              
 261   1          last_status0 = temp_status0;    
 262   1          last_status1 = temp_status1;
 263   1          
 264   1          return key_info.WhichKey;
 265   1      }
 266          
 267          
 268          void Clear_Touch_Info(void)
 269          {
 270   1          key_info.IsCount = 0;
 271   1          key_info.count_times = 0;
 272   1          key_info.IsTouchedKey = 0;
 273   1          key_info.WhichKey = KEY_NONE;
 274   1      }
 275          
 276          
 277          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    622    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =      9      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
