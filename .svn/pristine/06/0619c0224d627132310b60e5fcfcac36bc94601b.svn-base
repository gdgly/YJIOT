C51 COMPILER V9.52.0.0   TM1620                                                            10/19/2017 17:26:14 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE TM1620
OBJECT MODULE PLACED IN .\Objects\TM1620.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\TM1620\TM1620.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER\IIC;.\
                    -USER\UART;.\USER\TM1618;.\USER\Sensor;.\USER;.\USER\PWM;.\USER\DC_MOTOR;.\USER\timer;.\USER\inc;.\USER\EXINT;.\USER\touc
                    -h_key;.\USER\SYS_RUN;.\USER\step_motor;.\USER\BUZZER;.\USER\UART;.\USER\common;.\USER\lib;.\USER\UV;.\USER\ION;.\USER\EE
                    -PROM;.\USER\TM1620;.\USER\charge) DEBUG OBJECTEXTEND PRINT(.\Listings\TM1620.lst) TABS(2) OBJECT(.\Objects\TM1620.obj)

line level    source

   1          #include "TM1620.h"
   2          #include "sensor.h"
   3          
   4          //buff[0]-buff[9]分别表示显示0-9，buff[10]表示数码管灭
   5          const unsigned char led_display_buff[11] = {
   6           //0-4
   7           0x3F,0x06,0x5B,0x4F,0x66,
   8          //5-9
   9          0x6D,0x7D,0x07,0x7F,0x6F,
  10          //灭
  11          0x00
  12          
  13          
  14          };
  15          
  16          static void mydelay(int num)
  17          {
  18   1          while(num--);
  19   1      }
  20            
  21          void TM1620_Pin_Config(void)
  22          {
  23   1          //PIN设置为推挽输出，PxM0对应的位置1，PxM1对应的位置0
  24   1          P1M0 |= ((1 << 3) | (1 << 4) | (1 << 5));
  25   1          P1M1 &= ~((1 << 3) | (1 << 4) | (1 << 5));
  26   1          TM1620_STB_PIN = 1;
  27   1          TM1620_CLK_PIN = 1;
  28   1          TM1620_DIO_PIN = 1;
  29   1        
  30   1      }
  31          
  32          
  33          
  34          //刚上电后设置显示模式5位7段，把TM1620的显示寄存器0xC0-0xCD全部写0
  35          void TM1620_Init(void)
  36          {
  37   1          TM1620_Pin_Config();
  38   1          TM1620_SetMode();
  39   1          TM1620_Clear_Framebuff();
  40   1          TM1620_Display_On();
  41   1      }
  42          
  43          
  44          void TM1620_WriteOneByte(unsigned char senddata)
  45          {
  46   1          unsigned char i = 0;
  47   1          unsigned char tempdata = 0;
  48   1        
  49   1          tempdata = senddata;
  50   1          //TM1620_STB_PIN = 0;
  51   1        
  52   1          
C51 COMPILER V9.52.0.0   TM1620                                                            10/19/2017 17:26:14 PAGE 2   

  53   1          for(i = 0;i < 8;i++)
  54   1          {
  55   2              TM1620_CLK_PIN = 0;
  56   2              if(tempdata & 0x01)
  57   2              {
  58   3                  TM1620_DIO_PIN = 1;
  59   3              }
  60   2              else
  61   2              {
  62   3                  TM1620_DIO_PIN = 0;
  63   3              }
  64   2              //TM1620_CLK_PIN = 0;
  65   2              mydelay(1);
  66   2              TM1620_CLK_PIN = 1;
  67   2              mydelay(1);
  68   2              
  69   2              tempdata = tempdata >> 1;       
  70   2          }
  71   1          //TM1620_STB_PIN = 1;    
  72   1      }
  73          
  74          /*
  75          void TM1620_WriteBytes(const unsigned char *senddata,unsigned char num)
  76          {
  77              unsigned char i,j = 0;
  78              unsigned char tempdata = 0;
  79            
  80              //TM1620_STB_PIN = 0;
  81            
  82              for(j = 0;j < num;j++)
  83              {
  84                  tempdata = *(senddata + j);
  85                  for(i = 0;i < 8;i++)
  86                  {
  87                      TM1620_CLK_PIN = 0;
  88                      if(tempdata & 0x01)
  89                      {
  90                          TM1620_DIO_PIN = 1;
  91                      }
  92                      else
  93                      {
  94                          TM1620_DIO_PIN = 0;
  95                      }           
  96                      mydelay(2);
  97                      TM1620_CLK_PIN = 1;
  98                      mydelay(1);
  99                  
 100                      tempdata = tempdata >> 1;       
 101                  }
 102              }
 103              //TM1620_STB_PIN = 1;    
 104          }
 105          */
 106          
 107          //设置为5位7段模式
 108          void TM1620_SetMode(void)
 109          {
 110   1          TM1620_STB_PIN = 0;
 111   1          TM1620_WriteOneByte(TM1620_MODE_CMD);
 112   1          TM1620_STB_PIN = 1;
 113   1      }
 114          
C51 COMPILER V9.52.0.0   TM1620                                                            10/19/2017 17:26:14 PAGE 3   

 115          //设置数据命令
 116          void TM1620_SetDataMode(void)
 117          {
 118   1          TM1620_STB_PIN = 0;
 119   1          TM1620_WriteOneByte(TM1620_DATA_CMD);
 120   1          TM1620_STB_PIN = 1;
 121   1      }
 122          
 123          //往TM1620的显示寄存器中写数据，该函数指针对GRID1 GRID2 GRID3控制的数码管
 124          void TM1620_WriteFrameRegister(unsigned char sensortype,unsigned char grid_num,unsigned char *displaybuff,
             -unsigned char bufferlength)
 125          {
 126   1          unsigned char i = 0;
 127   1          unsigned char address = 0;
 128   1          unsigned char senddata = 0;
 129   1         
 130   1          if(grid_num >= GRID_MAX || grid_num == 0)
 131   1          {
 132   2              return;
 133   2          }
 134   1          
 135   1          if(bufferlength > ((7 - grid_num) * 2))
 136   1          {
 137   2              //采用的是6位8段模式，要写入显示寄存器的长度不能超过显示寄存器的范围
 138   2              return;
 139   2          }
 140   1          
 141   1          address = TM1620_ADDR_CMD_BASE + (grid_num - 1) * 2;
 142   1        
 143   1          TM1620_SetDataMode();
 144   1          mydelay(2);
 145   1          TM1620_STB_PIN = 0; 
 146   1          //设置数据传送寄存器首地址  
 147   1          TM1620_WriteOneByte(address);
 148   1          for(i = 0;i < bufferlength;i++)
 149   1          { 
 150   2              senddata = 0;
 151   2            
 152   2              if(sensortype == SENSOR_HCHO && i == 4)
 153   2              {
 154   3                  //显示甲醛数据的话需要增加小数点
 155   3                  senddata = led_display_buff[displaybuff[i]] | (1 << 7);
 156   3              }
 157   2              else
 158   2              {
 159   3                  senddata = led_display_buff[displaybuff[i]];
 160   3              }          
 161   2              //TM1620_WriteOneByte(led_display_buff[displaybuff[i]] | (1 << 7)); 
 162   2              TM1620_WriteOneByte(senddata);  
 163   2                  
 164   2          }
 165   1          TM1620_STB_PIN = 1;
 166   1      }
 167          
 168          //把显示寄存器清零
 169          void TM1620_Clear_Framebuff(void)
 170          {
 171   1          unsigned char i = 0;
 172   1        
 173   1          TM1620_SetDataMode();
 174   1        
 175   1          TM1620_STB_PIN = 0;
C51 COMPILER V9.52.0.0   TM1620                                                            10/19/2017 17:26:14 PAGE 4   

 176   1          TM1620_WriteOneByte(TM1620_ADDR_CMD_BASE);
 177   1          for(i = 0;i < 12;i++)
 178   1          {
 179   2              TM1620_WriteOneByte(0x00);
 180   2          }     
 181   1          TM1620_STB_PIN = 1;
 182   1        
 183   1      }
 184          
 185          void TM1620_Display_On(void)
 186          {
 187   1          TM1620_STB_PIN = 0;
 188   1          TM1620_WriteOneByte(TM1620_PULSE_WIDTH_10_16);
 189   1          TM1620_STB_PIN = 1;
 190   1      }
 191          
 192          /*
 193          void TM1620_Display_Off(void)
 194          {
 195              TM1620_STB_PIN = 0;
 196              TM1620_WriteOneByte(TM1620_OFF);
 197              TM1620_STB_PIN = 1;
 198          }
 199          */
 200          
 201          void TM1620_DispalyData(unsigned char sensor,float sensordata)
 202          {
 203   1          unsigned char j = 0;
 204   1          unsigned char displaybuff[5] = {0};
 205   1          unsigned int displaydata = 0;
 206   1          if(sensor == SENSOR_HCHO)
 207   1          {
 208   2              if(sensordata >= 10)
 209   2              {
 210   3                  displaydata = 999;         
 211   3              }
 212   2              else
 213   2              {
 214   3                  displaydata = (int)(sensordata * 100);
 215   3              }
 216   2      
 217   2          }
 218   1          else if(sensor == SENSOR_PM25)
 219   1          {
 220   2              if(sensordata >= 1000)
 221   2              {
 222   3                  displaydata = 999;
 223   3              }
 224   2              else
 225   2              {
 226   3                  displaydata = (int)sensordata;
 227   3              }
 228   2          }
 229   1          
 230   1      
 231   1      //    displaybuff[2] = displaydata / 100;
 232   1      //    displaybuff[1] = (displaydata % 100) / 10;
 233   1      //    displaybuff[0] = displaydata % 10;
 234   1          //最左边数码管显示的数据
 235   1          displaybuff[4] = displaydata / 100;
 236   1          //displaybuff[1] = displaydata / 100;
 237   1          //中间数码管显示的数据
C51 COMPILER V9.52.0.0   TM1620                                                            10/19/2017 17:26:14 PAGE 5   

 238   1          displaybuff[2] = (displaydata % 100) / 10;
 239   1          //最右边数码管显示的数据
 240   1          displaybuff[0] = displaydata % 10;
 241   1          
 242   1          if(sensor == SENSOR_HCHO)
 243   1          {
 244   2      //        TM1620_WriteFrameRegister(displaybuff,1);
 245   2      //        //显示甲醛数据的时候要显示小数点
 246   2      //        LED1_DP_PIN = 1;
 247   2      //        mydelay(3);
 248   2      //        LED1_DP_PIN = 0;
 249   2      //        TM1620_WriteFrameRegister(displaybuff,1);
 250   2              
 251   2          }
 252   1          else if(sensor == SENSOR_PM25)
 253   1          {
 254   2      
 255   2          }
 256   1          
 257   1          TM1620_WriteFrameRegister(sensor,GRID1,displaybuff,5);
 258   1          
 259   1          
 260   1      }
 261          
 262          
 263          void TM1820_LED_Control(unsigned char led,unsigned char on_off)
 264          {
 265   1          
 266   1          //static unsigned char led_group_data[4] = {0};
 267   1          static unsigned char led_group1_data = 0;
 268   1          static unsigned char led_group2_data = 0;
 269   1        
 270   1          unsigned char register_addr = 0x00;
 271   1          unsigned char register_data = 0x00;
 272   1          //unsigned char grid = 0;
 273   1            
 274   1          if(led >= LED_MAX_NUM || on_off >= 2)
 275   1          {
 276   2              return;
 277   2          }
 278   1          
 279   1          if(led <= LED_UV)
 280   1          {
 281   2              //register_addr = TM1620_ADDR_CMD_BASE + (LED_GROUP1_GRID_NUM - 1) * 2;  
 282   2              if(on_off == 1)
 283   2              {
 284   3                  if(led >= LED_QUIET && led <= LED_SPEED_HIGH)
 285   3                  {
 286   4                      led_group1_data &= ~((1 << LED_QUIET) | (1 << LED_SPEED_LOW) | (1 << LED_SPEED_MID) | (1 <
             -< LED_SPEED_HIGH));
 287   4                  }
 288   3                  led_group1_data |= (1 << led);
 289   3              } 
 290   2              else
 291   2              {
 292   3                  led_group1_data &= ~(1 << led);
 293   3              } 
 294   2              register_addr = TM1620_ADDR_CMD_BASE + 0x08;  
 295   2              register_data = led_group1_data; 
 296   2                     
 297   2          }
 298   1          else if(led < LED_ALL)
C51 COMPILER V9.52.0.0   TM1620                                                            10/19/2017 17:26:14 PAGE 6   

 299   1          {
 300   2              //register_addr = TM1620_ADDR_CMD_BASE + (LED_GROUP2_GRID_NUM - 1) * 2;   
 301   2              if(on_off == 1)
 302   2              {
 303   3                  led_group2_data |= (1 << (led - LED_ION));
 304   3              } 
 305   2              else
 306   2              {
 307   3                  led_group2_data &= ~(1 << (led - LED_ION));
 308   3              } 
 309   2              register_addr = TM1620_ADDR_CMD_BASE + 0x0A;  
 310   2              register_data = led_group2_data;         
 311   2          }
 312   1          else if(led == LED_ALL)
 313   1          {
 314   2              if(on_off == 1)
 315   2              {
 316   3                  led_group1_data = 0x7F;
 317   3                  led_group2_data = 0x7F;
 318   3              } 
 319   2              else
 320   2              {
 321   3                  led_group1_data = (1 << LED_POWER);
 322   3                  led_group2_data = 0x00;
 323   3              } 
 324   2              register_addr = TM1620_ADDR_CMD_BASE + 0x08;           
 325   2          }
 326   1          
 327   1          //TM1620_WriteFrameRegister(GRID5,led_group_data,1);
 328   1          TM1620_SetDataMode();
 329   1          mydelay(2);
 330   1          TM1620_STB_PIN = 0; 
 331   1          //设置数据传送寄存器首地址  
 332   1          TM1620_WriteOneByte(register_addr);
 333   1          if(led != LED_ALL)
 334   1          {
 335   2              TM1620_WriteOneByte(register_data);   
 336   2          }
 337   1          else
 338   1          {
 339   2              TM1620_WriteOneByte(led_group1_data);
 340   2              TM1620_WriteOneByte(led_group2_data);
 341   2          }
 342   1      
 343   1          TM1620_STB_PIN = 1;
 344   1          
 345   1      }
 346          
 347          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    831    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =     13      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
