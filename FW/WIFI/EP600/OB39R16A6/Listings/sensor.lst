C51 COMPILER V9.52.0.0   SENSOR                                                            12/18/2017 15:06:01 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE SENSOR
OBJECT MODULE PLACED IN .\Objects\sensor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\Sensor\sensor.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER\IIC;.\
                    -USER\UART;.\USER\TM1618;.\USER\Sensor;.\USER;.\USER\PWM;.\USER\DC_MOTOR;.\USER\timer;.\USER\inc;.\USER\EXINT;.\USER\touc
                    -h_key;.\USER\SYS_RUN;.\USER\step_motor;.\USER\BUZZER;.\USER\UART;.\USER\common;.\USER\lib;.\USER\UV;.\USER\ION;.\USER\EE
                    -PROM;.\USER\TM1620;.\USER\charge) DEBUG OBJECTEXTEND PRINT(.\Listings\sensor.lst) TABS(2) OBJECT(.\Objects\sensor.obj)

line level    source

   1          #include <stdio.h>
   2          #include "sensor.h"
   3          #include "SOFT_IIC.h"
   4          #include "global.h"
   5          #include "debug_uart.h"
   6          
   7          
   8          
   9          #define SENSOR_IIC_DELAY_COUNT  2
  10          
  11          void sensor_i2c_delay(void)
  12          {
  13   1        int i = 0;
  14   1        for(i = 0;i < SENSOR_IIC_DELAY_COUNT;i++);
  15   1      }
  16          
  17          
  18          void SENSOR_IIC_PinConifg(void)
  19          {
  20   1          //PIN设置为推挽输出，PxM0对应的位置1，PxM1对应的位置0  
  21   1          SENSOR_IIC_PxM0 &= ~((1 << SENSOR_IIC_SDA_PORTBIT) | (1 << SENSOR_IIC_SCL_PORTBIT));
  22   1          SENSOR_IIC_PxM1 &= ~((1 << SENSOR_IIC_SDA_PORTBIT) | (1 << SENSOR_IIC_SCL_PORTBIT));
  23   1        
  24   1          SENSOR_IIC_SCL_PIN = 1;
  25   1          SENSOR_IIC_SDA_PIN = 1;
  26   1      }
  27          
  28          
  29          
  30          void Set_Sensor_SDA_Pin_Mode(unsigned char mode)
  31          {
  32   1          if(mode == PIN_INPUT)
  33   1          {
  34   2              //PIN设置为输入时，PxM0对应的位置0，PxM1对应的位置1
  35   2              SENSOR_IIC_PxM0 &= ~(1 << SENSOR_IIC_SDA_PORTBIT);
  36   2              SENSOR_IIC_PxM1 |= (1 << SENSOR_IIC_SDA_PORTBIT);
  37   2          }
  38   1          else if(mode == PIN_OUTPUT)
  39   1          {      
  40   2              SENSOR_IIC_PxM0 &= ~(1 << SENSOR_IIC_SDA_PORTBIT);
  41   2              SENSOR_IIC_PxM1 &= ~(1 << SENSOR_IIC_SDA_PORTBIT);
  42   2          }
  43   1      }
  44            
  45          void Set_Sensor_SCL_Pin_Mode(unsigned char mode)
  46          {
  47   1          if(mode == PIN_INPUT)
  48   1          {
  49   2              //PIN设置为输入时，PxM0对应的位置0，PxM1对应的位置1
  50   2              SENSOR_IIC_PxM0 &= ~(1 << SENSOR_IIC_SCL_PORTBIT);
  51   2              SENSOR_IIC_PxM1 |= ((1 << SENSOR_IIC_SCL_PORTBIT));
  52   2          }
C51 COMPILER V9.52.0.0   SENSOR                                                            12/18/2017 15:06:01 PAGE 2   

  53   1          else if(mode == PIN_OUTPUT)
  54   1          {      
  55   2              SENSOR_IIC_PxM0 &= ~(1 << SENSOR_IIC_SCL_PORTBIT);
  56   2              SENSOR_IIC_PxM1 &= ~(1 << SENSOR_IIC_SCL_PORTBIT);     
  57   2          }
  58   1      
  59   1      }
  60          
  61          
  62          void Sensor_IIC_SDA_1(void)
  63          {
  64   1          SENSOR_IIC_SDA_PIN = 1;
  65   1      }
  66          
  67          void Sensor_IIC_SDA_0(void)
  68          {
  69   1          SENSOR_IIC_SDA_PIN = 0;
  70   1      }
  71          
  72          void Sensor_IIC_SCL_1(void)
  73          {
  74   1          SENSOR_IIC_SCL_PIN = 1;
  75   1      }
  76          void Sensor_IIC_SCL_0(void)
  77          {
  78   1          SENSOR_IIC_SCL_PIN = 0;
  79   1      }
  80          
  81          
  82          unsigned char Sensor_IIC_SDA_READ(void)
  83          {
  84   1          return (SENSOR_IIC_SDA_PIN ? 1 : 0);
  85   1      }
  86          
  87          /*
  88          HPD05传感器寄存器0x26存放的当前粉尘浓度的低8位，寄存器0x27存放的是当前粉尘浓度的高8位
  89          地址为0x9A 通讯波特率最大100kbps
  90          */
  91          unsigned int Read_PMSensor_Data(void)
  92          {
  93   1          static unsigned int last_pm_data = 0;
  94   1          unsigned char readaddr = HPD05_DATA_START_ADDR;
  95   1          unsigned char res = 1;
  96   1          unsigned int pm_data = 0;
  97   1        
  98   1          unsigned char readbuff[5] = {0};
  99   1          
 100   1          //unsigned char debug_buff[30] = {0};
 101   1      
 102   1          IIC_Operations.IIC_NUM = HPD05_IIC;
 103   1          IIC_Operations.Set_SDA_Pin_Mode = Set_Sensor_SDA_Pin_Mode;
 104   1          IIC_Operations.Set_SCL_Pin_Mode = Set_Sensor_SCL_Pin_Mode;
 105   1          IIC_Operations.i2c_delay = sensor_i2c_delay;
 106   1          IIC_Operations.SDA_1 = Sensor_IIC_SDA_1;
 107   1          IIC_Operations.SDA_0 = Sensor_IIC_SDA_0;
 108   1          IIC_Operations.SCL_1 = Sensor_IIC_SCL_1;
 109   1          IIC_Operations.SCL_0 = Sensor_IIC_SCL_0;
 110   1          IIC_Operations.I2C_SDA_READ = Sensor_IIC_SDA_READ;
 111   1        
 112   1          res = I2C_WriteBytes(HPD05_ADDRESS,&readaddr,1);
 113   1         
 114   1          if(res == 0)
C51 COMPILER V9.52.0.0   SENSOR                                                            12/18/2017 15:06:01 PAGE 3   

 115   1          {
 116   2              res = I2C_ReadBytes(HPD05_ADDRESS,readbuff,5);     
 117   2          }
 118   1          
 119   1          
 120   1          if(readbuff[0] & 0x01)
 121   1          {
 122   2              pm_data = ((unsigned int)readbuff[1]) << 8 | readbuff[2]; 
 123   2              if(pm_data == 0)
 124   2              {
 125   3                  pm_data = last_pm_data;
 126   3              }
 127   2            
 128   2      //        mymemset(debug_buff,0,30);
 129   2      //        sprintf(debug_buff,"buff:%x %x,pm_data:%d\n",(unsigned int)readbuff[1],(unsigned int)readbuff[2]
             -,(unsigned int)pm_data);
 130   2      //        DEBUG_Uart_Sendbytes(debug_buff,mystrlen(debug_buff));
 131   2            
 132   2            
 133   2      //        if(pm_data == 0)
 134   2      //        {
 135   2      //            pm_data = 2;
 136   2      //        }          
 137   2          }
 138   1          else
 139   1          {
 140   2              pm_data = last_pm_data;
 141   2              
 142   2          }
 143   1          
 144   1          last_pm_data = pm_data;
 145   1          
 146   1          /*
 147   1          if(pm_data <= 5)
 148   1          {
 149   1              pm_data = 5;
 150   1          } 
 151   1          else if(pm_data <= 10)
 152   1          {
 153   1              pm_data = 10;
 154   1          }
 155   1          else if(pm_data <= 15)
 156   1          {
 157   1              pm_data = 15;
 158   1          } 
 159   1          else if(pm_data <= 20)
 160   1          {
 161   1              pm_data = 20;
 162   1          }
 163   1          */
 164   1          
 165   1          return pm_data;
 166   1      
 167   1      }
 168          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    324    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =      2       8
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.52.0.0   SENSOR                                                            12/18/2017 15:06:01 PAGE 4   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
