C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE VSPRINTF
OBJECT MODULE PLACED IN .\Objects\vsprintf.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\lib\vsprintf.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER\IIC;.\U
                    -SER\UART;.\USER\TM1618;.\USER\Sensor;.\USER;.\USER\PWM;.\USER\DC_MOTOR;.\USER\timer;.\USER\inc;.\USER\EXINT;.\USER\touch
                    -_key;.\USER\SYS_RUN;.\USER\step_motor;.\USER\BUZZER;.\USER\UART;.\USER\common;.\USER\lib) DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\vsprintf.lst) TABS(2) OBJECT(.\Objects\vsprintf.obj)

line level    source

   1          /*
   2           *  linux/lib/vsprintf.c
   3           *
   4           *  Copyright (C) 1991, 1992  Linus Torvalds
   5           */
   6          
   7          /* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */
   8          /*
   9           * Wirzenius wrote this portably, Torvalds fucked it up :-)
  10           */
  11          
  12          /* 
  13           * Fri Jul 13 2001 Crutcher Dunnavant <crutcher+kernel@datastacks.com>
  14           * - changed to provide snprintf and vsnprintf functions
  15           * So Feb  1 16:51:32 CET 2004 Juergen Quade <quade@hsnr.de>
  16           * - scnprintf and vscnprintf
  17           */
  18          
  19          //#include <stdarg.h>
  20          //#include <linux/module.h>
  21          #include "types.h"
  22          #include "kernel.h"
  23          
  24          #include "ctype.h"
  25          //#include "string.h"
  26          //#include "div64.h"
  27          #include "vsprintf.h"
  28          #include <string.h>
  29          
  30          #define unlikely(x) __builtin_expect(!!(x), 0)
  31          
  32          /**
  33           * simple_strtoul - convert a string to an unsigned long
  34           * @cp: The start of the string
  35           * @endp: A pointer to the end of the parsed string will be placed here
  36           * @base: The number base to use
  37           */
  38          unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
  39          {
  40   1        unsigned long result = 0,value;
  41   1      
  42   1        if (!base) {
  43   2          base = 10;
  44   2          if (*cp == '0') {
  45   3            base = 8;
  46   3            cp++;
  47   3            if ((toupper(*cp) == 'X') && isxdigit(cp[1])) {
  48   4              cp++;
  49   4              base = 16;
  50   4            }
  51   3          }
  52   2        } else if (base == 16) {
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 2   

  53   2          if (cp[0] == '0' && toupper(cp[1]) == 'X')
  54   2            cp += 2;
  55   2        }
  56   1        while (isxdigit(*cp) &&
  57   1               (value = isdigit(*cp) ? *cp-'0' : toupper(*cp)-'A'+10) < base) {
  58   2          result = result*base + value;
  59   2          cp++;
  60   2        }
  61   1        if (endp)
  62   1          *endp = (char *)cp;
  63   1        return result;
  64   1      }
  65          
  66          //EXPORT_SYMBOL(simple_strtoul);
  67          
  68          /**
  69           * simple_strtol - convert a string to a signed long
  70           * @cp: The start of the string
  71           * @endp: A pointer to the end of the parsed string will be placed here
  72           * @base: The number base to use
  73           */
  74          long simple_strtol(const char *cp,char **endp,unsigned int base)
  75          {
  76   1        if(*cp=='-')
  77   1          return -simple_strtoul(cp+1,endp,base);
  78   1        return simple_strtoul(cp,endp,base);
  79   1      }
  80          
  81          //EXPORT_SYMBOL(simple_strtol);
  82          
  83          /**
  84           * simple_strtoull - convert a string to an unsigned long long
  85           * @cp: The start of the string
  86           * @endp: A pointer to the end of the parsed string will be placed here
  87           * @base: The number base to use
  88           */
  89          unsigned  long simple_strtoull(const char *cp,char **endp,unsigned int base)
  90          {
  91   1        unsigned  long result = 0,value;
  92   1      
  93   1        if (!base) {
  94   2          base = 10;
  95   2          if (*cp == '0') {
  96   3            base = 8;
  97   3            cp++;
  98   3            if ((toupper(*cp) == 'X') && isxdigit(cp[1])) {
  99   4              cp++;
 100   4              base = 16;
 101   4            }
 102   3          }
 103   2        } else if (base == 16) {
 104   2          if (cp[0] == '0' && toupper(cp[1]) == 'X')
 105   2            cp += 2;
 106   2        }
 107   1        while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
 108   1            ? toupper(*cp) : *cp)-'A'+10) < base) {
 109   2          result = result*base + value;
 110   2          cp++;
 111   2        }
 112   1        if (endp)
 113   1          *endp = (char *)cp;
 114   1        return result;
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 3   

 115   1      }
 116          
 117          //EXPORT_SYMBOL(simple_strtoull);
 118          
 119          /**
 120           * simple_strtoll - convert a string to a signed long long
 121           * @cp: The start of the string
 122           * @endp: A pointer to the end of the parsed string will be placed here
 123           * @base: The number base to use
 124           */
 125          long simple_strtoll(const char *cp,char **endp,unsigned int base)
 126          {
 127   1        if(*cp=='-')
 128   1          return -simple_strtoull(cp+1,endp,base);
 129   1        return simple_strtoull(cp,endp,base);
 130   1      }
 131          
 132          static int skip_atoi(const char **s)
 133          {
 134   1        int i=0;
 135   1      
 136   1        while (isdigit(**s))
 137   1          i = i*10 + *((*s)++) - '0';
 138   1        return i;
 139   1      }
 140          
 141          #define ZEROPAD 1   /* pad with zero */
 142          #define SIGN  2   /* unsigned/signed long */
 143          #define PLUS  4   /* show plus */
 144          #define SPACE 8   /* space if plus */
 145          #define LEFT  16    /* left justified */
 146          #define SPECIAL 32    /* 0x */
 147          #define LARGE 64    /* use 'ABCDEF' instead of 'abcdef' */
 148          
 149          static char * number(char * buf, char * end, unsigned long num, int base, int size, int precision, int typ
             -e)
 150          {
 151   1        char c,sign,tmp[66];
 152   1        const char *digits;
 153   1        static const char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
 154   1        static const char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 155   1        int i;
 156   1      
 157   1        digits = (type & LARGE) ? large_digits : small_digits;
 158   1        if (type & LEFT)
 159   1          type &= ~ZEROPAD;
 160   1        if (base < 2 || base > 36)
 161   1          return NULL;
 162   1        c = (type & ZEROPAD) ? '0' : ' ';
 163   1        sign = 0;
 164   1        if (type & SIGN) {
 165   2          if ((signed long) num < 0) {
 166   3            sign = '-';
 167   3            num = - (signed long) num;
 168   3            size--;
 169   3          } else if (type & PLUS) {
 170   3            sign = '+';
 171   3            size--;
 172   3          } else if (type & SPACE) {
 173   3            sign = ' ';
 174   3            size--;
 175   3          }
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 4   

 176   2        }
 177   1        if (type & SPECIAL) {
 178   2          if (base == 16)
 179   2            size -= 2;
 180   2          else if (base == 8)
 181   2            size--;
 182   2        }
 183   1        i = 0;
 184   1        if (num == 0)
 185   1          tmp[i++]='0';
 186   1        else while (num != 0)
 187   1          tmp[i++] = digits[do_div(num,base)];
*** WARNING C206 IN LINE 187 OF USER\lib\vsprintf.c: 'do_div': missing function-prototype
*** ERROR C267 IN LINE 187 OF USER\lib\vsprintf.c: 'do_div': requires ANSI-style prototype
 188   1        if (i > precision)
 189   1          precision = i;
 190   1        size -= precision;
 191   1        if (!(type&(ZEROPAD+LEFT))) {
 192   2          while(size-->0) {
 193   3            if (buf <= end)
 194   3              *buf = ' ';
 195   3            ++buf;
 196   3          }
 197   2        }
 198   1        if (sign) {
 199   2          if (buf <= end)
 200   2            *buf = sign;
 201   2          ++buf;
 202   2        }
 203   1        if (type & SPECIAL) {
 204   2          if (base==8) {
 205   3            if (buf <= end)
 206   3              *buf = '0';
 207   3            ++buf;
 208   3          } else if (base==16) {
 209   3            if (buf <= end)
 210   3              *buf = '0';
 211   3            ++buf;
 212   3            if (buf <= end)
 213   3              *buf = digits[33];
 214   3            ++buf;
 215   3          }
 216   2        }
 217   1        if (!(type & LEFT)) {
 218   2          while (size-- > 0) {
 219   3            if (buf <= end)
 220   3              *buf = c;
 221   3            ++buf;
 222   3          }
 223   2        }
 224   1        while (i < precision--) {
 225   2          if (buf <= end)
 226   2            *buf = '0';
 227   2          ++buf;
 228   2        }
 229   1        while (i-- > 0) {
 230   2          if (buf <= end)
 231   2            *buf = tmp[i];
 232   2          ++buf;
 233   2        }
 234   1        while (size-- > 0) {
 235   2          if (buf <= end)
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 5   

 236   2            *buf = ' ';
 237   2          ++buf;
 238   2        }
 239   1        return buf;
 240   1      }
 241          
 242          /**
 243           * vsnprintf - Format a string and place it in a buffer
 244           * @buf: The buffer to place the result into
 245           * @size: The size of the buffer, including the trailing null space
 246           * @fmt: The format string to use
 247           * @args: Arguments for the format string
 248           *
 249           * The return value is the number of characters which would
 250           * be generated for the given input, excluding the trailing
 251           * '\0', as per ISO C99. If you want to have the exact
 252           * number of characters written into @buf as return value
 253           * (not including the trailing '\0'), use vscnprintf. If the
 254           * return is greater than or equal to @size, the resulting
 255           * string is truncated.
 256           *
 257           * Call this function if you are already dealing with a va_list.
 258           * You probably want snprintf instead.
 259           */
 260          int vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
 261          {
 262   1        int len;
 263   1        unsigned long long num;
*** ERROR C141 IN LINE 263 OF USER\lib\vsprintf.c: syntax error near 'long'
 264   1        int i, base;
 265   1        char *str, *end, c;
 266   1        const char *s;
 267   1      
 268   1        int flags;    /* flags to number() */
 269   1      
 270   1        int field_width;  /* width of output field */
 271   1        int precision;    /* min. # of digits for integers; max
 272   1                 number of chars for from string */
 273   1        int qualifier;    /* 'h', 'l', or 'L' for integer fields */
 274   1              /* 'z' support added 23/7/1999 S.H.    */
 275   1              /* 'z' changed to 'Z' --davidm 1/25/99 */
 276   1      
 277   1        /* Reject out-of-range values early */
 278   1        if (unlikely((int) size < 0)) {
 279   2          /* There can be only one.. */
 280   2          static int warn = 1;
 281   2      //    WARN_ON(warn);
 282   2          warn = 0;
 283   2          return 0;
 284   2        }
 285   1      
 286   1        str = buf;
 287   1        end = buf + size - 1;
 288   1      
 289   1        if (end < buf - 1) {
 290   2          end = ((void *) -1);
 291   2          size = end - buf + 1;
 292   2        }
 293   1      
 294   1        for (; *fmt ; ++fmt) {
 295   2          if (*fmt != '%') {
 296   3            if (str <= end)
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 6   

 297   3              *str = *fmt;
 298   3            ++str;
 299   3            continue;
 300   3          }
 301   2      
 302   2          /* process flags */
 303   2          flags = 0;
 304   2          repeat:
 305   2            ++fmt;    /* this also skips first '%' */
 306   2            switch (*fmt) {
 307   3              case '-': flags |= LEFT; goto repeat;
 308   3              case '+': flags |= PLUS; goto repeat;
 309   3              case ' ': flags |= SPACE; goto repeat;
 310   3              case '#': flags |= SPECIAL; goto repeat;
 311   3              case '0': flags |= ZEROPAD; goto repeat;
 312   3            }
 313   2      
 314   2          /* get field width */
 315   2          field_width = -1;
 316   2          if (isdigit(*fmt))
 317   2            field_width = skip_atoi(&fmt);
 318   2          else if (*fmt == '*') {
 319   3            ++fmt;
 320   3            /* it's the next argument */
 321   3            field_width = va_arg(args, int);
 322   3            if (field_width < 0) {
 323   4              field_width = -field_width;
 324   4              flags |= LEFT;
 325   4            }
 326   3          }
 327   2      
 328   2          /* get the precision */
 329   2          precision = -1;
 330   2          if (*fmt == '.') {
 331   3            ++fmt;  
 332   3            if (isdigit(*fmt))
 333   3              precision = skip_atoi(&fmt);
 334   3            else if (*fmt == '*') {
 335   4              ++fmt;
 336   4              /* it's the next argument */
 337   4              precision = va_arg(args, int);
 338   4            }
 339   3            if (precision < 0)
 340   3              precision = 0;
 341   3          }
 342   2      
 343   2          /* get the conversion qualifier */
 344   2          qualifier = -1;
 345   2          if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
 346   2              *fmt =='Z' || *fmt == 'z') {
 347   3            qualifier = *fmt;
 348   3            ++fmt;
 349   3            if (qualifier == 'l' && *fmt == 'l') {
 350   4              qualifier = 'L';
 351   4              ++fmt;
 352   4            }
 353   3          }
 354   2      
 355   2          /* default base */
 356   2          base = 10;
 357   2      
 358   2          switch (*fmt) {
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 7   

 359   3            case 'c':
 360   3              if (!(flags & LEFT)) {
 361   4                while (--field_width > 0) {
 362   5                  if (str <= end)
 363   5                    *str = ' ';
 364   5                  ++str;
 365   5                }
 366   4              }
 367   3              c = (unsigned char) va_arg(args, int);
 368   3              if (str <= end)
 369   3                *str = c;
 370   3              ++str;
 371   3              while (--field_width > 0) {
 372   4                if (str <= end)
 373   4                  *str = ' ';
 374   4                ++str;
 375   4              }
 376   3              continue;
 377   3      
 378   3            case 's':
 379   3              s = va_arg(args, char *);
 380   3              if ((unsigned long)s < 1024)//PAGE_SIZE)
 381   3                s = "<NULL>";
 382   3      
 383   3              len = strnlen(s, precision);
 384   3      
 385   3              if (!(flags & LEFT)) {
 386   4                while (len < field_width--) {
 387   5                  if (str <= end)
 388   5                    *str = ' ';
 389   5                  ++str;
 390   5                }
 391   4              }
 392   3              for (i = 0; i < len; ++i) {
 393   4                if (str <= end)
 394   4                  *str = *s;
 395   4                ++str; ++s;
 396   4              }
 397   3              while (len < field_width--) {
 398   4                if (str <= end)
 399   4                  *str = ' ';
 400   4                ++str;
 401   4              }
 402   3              continue;
 403   3      
 404   3            case 'p':
 405   3              if (field_width == -1) {
 406   4                field_width = 2*sizeof(void *);
 407   4                flags |= ZEROPAD;
 408   4              }
 409   3              str = number(str, end,
 410   3                  (unsigned long) va_arg(args, void *),
 411   3                  16, field_width, precision, flags);
 412   3              continue;
 413   3      
 414   3      
 415   3            case 'n':
 416   3              /* FIXME:
 417   3              * What does C99 say about the overflow case here? */
 418   3              if (qualifier == 'l') {
 419   4                long * ip = va_arg(args, long *);
 420   4                *ip = (str - buf);
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 8   

 421   4              } else if (qualifier == 'Z' || qualifier == 'z') {
 422   4                size_t * ip = va_arg(args, size_t *);
 423   4                *ip = (str - buf);
 424   4              } else {
 425   4                int * ip = va_arg(args, int *);
 426   4                *ip = (str - buf);
 427   4              }
 428   3              continue;
 429   3      
 430   3            case '%':
 431   3              if (str <= end)
 432   3                *str = '%';
 433   3              ++str;
 434   3              continue;
 435   3      
 436   3              /* integer number formats - set up the flags and "break" */
 437   3            case 'o':
 438   3              base = 8;
 439   3              break;
 440   3      
 441   3            case 'X':
 442   3              flags |= LARGE;
 443   3            case 'x':
 444   3              base = 16;
 445   3              break;
 446   3      
 447   3            case 'd':
 448   3            case 'i':
 449   3              flags |= SIGN;
 450   3            case 'u':
 451   3              break;
 452   3      
 453   3            default:
 454   3              if (str <= end)
 455   3                *str = '%';
 456   3              ++str;
 457   3              if (*fmt) {
 458   4                if (str <= end)
 459   4                  *str = *fmt;
 460   4                ++str;
 461   4              } else {
 462   4                --fmt;
 463   4              }
 464   3              continue;
 465   3          }
 466   2          if (qualifier == 'L')
 467   2            num = va_arg(args, long long);
 468   2          else if (qualifier == 'l') {
 469   3            num = va_arg(args, unsigned long);
 470   3            if (flags & SIGN)
 471   3              num = (signed long) num;
 472   3          } else if (qualifier == 'Z' || qualifier == 'z') {
 473   3            num = va_arg(args, size_t);
 474   3          } else if (qualifier == 'h') {
 475   3            num = (unsigned short) va_arg(args, int);
 476   3            if (flags & SIGN)
 477   3              num = (signed short) num;
 478   3          } else {
 479   3            num = va_arg(args, unsigned int);
 480   3            if (flags & SIGN)
 481   3              num = (signed int) num;
 482   3          }
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 9   

 483   2          str = number(str, end, num, base,
 484   2              field_width, precision, flags);
 485   2        }
 486   1        if (str <= end)
 487   1          *str = '\0';
 488   1        else if (size > 0)
 489   1          /* don't write out a null byte if the buf size is zero */
 490   1          *end = '\0';
 491   1        /* the trailing null byte doesn't count towards the total
 492   1        * ++str;
 493   1        */
 494   1        return str-buf;
 495   1      }
 496          
 497          //EXPORT_SYMBOL(vsnprintf);
 498          
 499          /**
 500           * vscnprintf - Format a string and place it in a buffer
 501           * @buf: The buffer to place the result into
 502           * @size: The size of the buffer, including the trailing null space
 503           * @fmt: The format string to use
 504           * @args: Arguments for the format string
 505           *
 506           * The return value is the number of characters which have been written into
 507           * the @buf not including the trailing '\0'. If @size is <= 0 the function
 508           * returns 0.
 509           *
 510           * Call this function if you are already dealing with a va_list.
 511           * You probably want scnprintf instead.
 512           */
 513          int vscnprintf(char *buf, size_t size, const char *fmt, va_list args)
 514          {
 515   1        int i;
 516   1      
 517   1        i=vsnprintf(buf,size,fmt,args);
 518   1        return (i >= size) ? (size - 1) : i;
 519   1      }
 520          
 521          //EXPORT_SYMBOL(vscnprintf);
 522          
 523          /**
 524           * snprintf - Format a string and place it in a buffer
 525           * @buf: The buffer to place the result into
 526           * @size: The size of the buffer, including the trailing null space
 527           * @fmt: The format string to use
 528           * @...: Arguments for the format string
 529           *
 530           * The return value is the number of characters which would be
 531           * generated for the given input, excluding the trailing null,
 532           * as per ISO C99.  If the return is greater than or equal to
 533           * @size, the resulting string is truncated.
 534           */
 535          int snprintf(char * buf, size_t size, const char *fmt, ...)
 536          {
 537   1        va_list args;
 538   1        int i;
 539   1      
 540   1        va_start(args, fmt);
 541   1        i=vsnprintf(buf,size,fmt,args);
 542   1        va_end(args);
 543   1        return i;
 544   1      }
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 10  

 545          
 546          //EXPORT_SYMBOL(snprintf);
 547          
 548          /**
 549           * scnprintf - Format a string and place it in a buffer
 550           * @buf: The buffer to place the result into
 551           * @size: The size of the buffer, including the trailing null space
 552           * @fmt: The format string to use
 553           * @...: Arguments for the format string
 554           *
 555           * The return value is the number of characters written into @buf not including
 556           * the trailing '\0'. If @size is <= 0 the function returns 0. If the return is
 557           * greater than or equal to @size, the resulting string is truncated.
 558           */
 559          
 560          int scnprintf(char * buf, size_t size, const char *fmt, ...)
 561          {
 562   1        va_list args;
 563   1        int i;
 564   1      
 565   1        va_start(args, fmt);
 566   1        i = vsnprintf(buf, size, fmt, args);
 567   1        va_end(args);
 568   1        return (i >= size) ? (size - 1) : i;
 569   1      }
 570          //EXPORT_SYMBOL(scnprintf);
 571          
 572          /**
 573           * vsprintf - Format a string and place it in a buffer
 574           * @buf: The buffer to place the result into
 575           * @fmt: The format string to use
 576           * @args: Arguments for the format string
 577           *
 578           * The function returns the number of characters written
 579           * into @buf. Use vsnprintf or vscnprintf in order to avoid
 580           * buffer overflows.
 581           *
 582           * Call this function if you are already dealing with a va_list.
 583           * You probably want sprintf instead.
 584           */
 585          int vsprintf(char *buf, const char *fmt, va_list args)
 586          {
 587   1        return vsnprintf(buf, (~0U)>>1, fmt, args);
 588   1      }
 589          
 590          //EXPORT_SYMBOL(vsprintf);
 591          
 592          /**
 593           * sprintf - Format a string and place it in a buffer
 594           * @buf: The buffer to place the result into
 595           * @fmt: The format string to use
 596           * @...: Arguments for the format string
 597           *
 598           * The function returns the number of characters written
 599           * into @buf. Use snprintf or scnprintf in order to avoid
 600           * buffer overflows.
 601           */
 602          int sprintf(char * buf, const char *fmt, ...)
 603          {
 604   1        va_list args;
 605   1        int i;
 606   1      
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 11  

 607   1        va_start(args, fmt);
 608   1      /*  putc('P');
 609   1        putc(0x0d);
 610   1        putc(0x0a);
 611   1      */  
 612   1        i=vsprintf(buf,fmt,args);
 613   1      /*  putc('E');
 614   1        putc(0x0d);
 615   1        putc(0x0a);
 616   1      */  
 617   1        va_end(args);
 618   1        return i;
 619   1      }
 620          
 621          //EXPORT_SYMBOL(sprintf);
 622          
 623          /**
 624           * vsscanf - Unformat a buffer into a list of arguments
 625           * @buf:  input buffer
 626           * @fmt:  format of buffer
 627           * @args: arguments
 628           */
 629          int vsscanf(const char * buf, const char * fmt, va_list args)
 630          {
 631   1        const char *str = buf;
 632   1        char *next;
 633   1        char digit;
 634   1        int num = 0;
 635   1        int qualifier;
 636   1        int base;
 637   1        int field_width;
 638   1        int is_sign = 0;
 639   1      
 640   1        while(*fmt && *str) {
 641   2          /* skip any white space in format */
 642   2          /* white space in format matchs any amount of
 643   2           * white space, including none, in the input.
 644   2           */
 645   2          if (isspace(*fmt)) {
 646   3            while (isspace(*fmt))
 647   3              ++fmt;
 648   3            while (isspace(*str))
 649   3              ++str;
 650   3          }
 651   2      
 652   2          /* anything that is not a conversion must match exactly */
 653   2          if (*fmt != '%' && *fmt) {
 654   3            if (*fmt++ != *str++)
 655   3              break;
 656   3            continue;
 657   3          }
 658   2      
 659   2          if (!*fmt)
 660   2            break;
 661   2          ++fmt;
 662   2          
 663   2          /* skip this conversion.
 664   2           * advance both strings to next white space
 665   2           */
 666   2          if (*fmt == '*') {
 667   3            while (!isspace(*fmt) && *fmt)
 668   3              fmt++;
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 12  

 669   3            while (!isspace(*str) && *str)
 670   3              str++;
 671   3            continue;
 672   3          }
 673   2      
 674   2          /* get field width */
 675   2          field_width = -1;
 676   2          if (isdigit(*fmt))
 677   2            field_width = skip_atoi(&fmt);
 678   2      
 679   2          /* get conversion qualifier */
 680   2          qualifier = -1;
 681   2          if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
 682   2              *fmt == 'Z' || *fmt == 'z') {
 683   3            qualifier = *fmt++;
 684   3            if (unlikely(qualifier == *fmt)) {
 685   4              if (qualifier == 'h') {
 686   5                qualifier = 'H';
 687   5                fmt++;
 688   5              } else if (qualifier == 'l') {
 689   5                qualifier = 'L';
 690   5                fmt++;
 691   5              }
 692   4            }
 693   3          }
 694   2          base = 10;
 695   2          is_sign = 0;
 696   2      
 697   2          if (!*fmt || !*str)
 698   2            break;
 699   2      
 700   2          switch(*fmt++) {
 701   3          case 'c':
 702   3          {
 703   4            char *s = (char *) va_arg(args,char*);
 704   4            if (field_width == -1)
 705   4              field_width = 1;
 706   4            do {
 707   5              *s++ = *str++;
 708   5            } while (--field_width > 0 && *str);
 709   4            num++;
 710   4          }
 711   3          continue;
 712   3          case 's':
 713   3          {
 714   4            char *s = (char *) va_arg(args, char *);
 715   4            if(field_width == -1)
 716   4              field_width = INT_MAX;
 717   4            /* first, skip leading white space in buffer */
 718   4            while (isspace(*str))
 719   4              str++;
 720   4      
 721   4            /* now copy until next white space */
 722   4            while (*str && !isspace(*str) && field_width--) {
 723   5              *s++ = *str++;
 724   5            }
 725   4            *s = '\0';
 726   4            num++;
 727   4          }
 728   3          continue;
 729   3          case 'n':
 730   3            /* return number of characters read so far */
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 13  

 731   3          {
 732   4            int *i = (int *)va_arg(args,int*);
 733   4            *i = str - buf;
 734   4          }
 735   3          continue;
 736   3          case 'o':
 737   3            base = 8;
 738   3            break;
 739   3          case 'x':
 740   3          case 'X':
 741   3            base = 16;
 742   3            break;
 743   3          case 'i':
 744   3                              base = 0;
 745   3          case 'd':
 746   3            is_sign = 1;
 747   3          case 'u':
 748   3            break;
 749   3          case '%':
 750   3            /* looking for '%' in str */
 751   3            if (*str++ != '%') 
 752   3              return num;
 753   3            continue;
 754   3          default:
 755   3            /* invalid format; stop here */
 756   3            return num;
 757   3          }
 758   2      
 759   2          /* have some sort of integer conversion.
 760   2           * first, skip white space in buffer.
 761   2           */
 762   2          while (isspace(*str))
 763   2            str++;
 764   2      
 765   2          digit = *str;
 766   2          if (is_sign && digit == '-')
 767   2            digit = *(str + 1);
 768   2      
 769   2          if (!digit
 770   2                          || (base == 16 && !isxdigit(digit))
 771   2                          || (base == 10 && !isdigit(digit))
 772   2                          || (base == 8 && (!isdigit(digit) || digit > '7'))
 773   2                          || (base == 0 && !isdigit(digit)))
 774   2              break;
 775   2      
 776   2          switch(qualifier) {
 777   3          case 'H': /* that's 'hh' in format */
 778   3            if (is_sign) {
 779   4              signed char *s = (signed char *) va_arg(args,signed char *);
 780   4              *s = (signed char) simple_strtol(str,&next,base);
 781   4            } else {
 782   4              unsigned char *s = (unsigned char *) va_arg(args, unsigned char *);
 783   4              *s = (unsigned char) simple_strtoul(str, &next, base);
 784   4            }
 785   3            break;
 786   3          case 'h':
 787   3            if (is_sign) {
 788   4              short *s = (short *) va_arg(args,short *);
 789   4              *s = (short) simple_strtol(str,&next,base);
 790   4            } else {
 791   4              unsigned short *s = (unsigned short *) va_arg(args, unsigned short *);
 792   4              *s = (unsigned short) simple_strtoul(str, &next, base);
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 14  

 793   4            }
 794   3            break;
 795   3          case 'l':
 796   3            if (is_sign) {
 797   4              long *l = (long *) va_arg(args,long *);
 798   4              *l = simple_strtol(str,&next,base);
 799   4            } else {
 800   4              unsigned long *l = (unsigned long*) va_arg(args,unsigned long*);
 801   4              *l = simple_strtoul(str,&next,base);
 802   4            }
 803   3            break;
 804   3          case 'L':
 805   3            if (is_sign) {
 806   4              long long *l = (long long*) va_arg(args,long long *);
 807   4              *l = simple_strtoll(str,&next,base);
 808   4            } else {
 809   4              unsigned long long *l = (unsigned long long*) va_arg(args,unsigned long long*);
 810   4              *l = simple_strtoull(str,&next,base);
 811   4            }
 812   3            break;
 813   3          case 'Z':
 814   3          case 'z':
 815   3          {
 816   4            size_t *s = (size_t*) va_arg(args,size_t*);
 817   4            *s = (size_t) simple_strtoul(str,&next,base);
 818   4          }
 819   3          break;
 820   3          default:
 821   3            if (is_sign) {
 822   4              int *i = (int *) va_arg(args, int*);
 823   4              *i = (int) simple_strtol(str,&next,base);
 824   4            } else {
 825   4              unsigned int *i = (unsigned int*) va_arg(args, unsigned int*);
 826   4              *i = (unsigned int) simple_strtoul(str,&next,base);
 827   4            }
 828   3            break;
 829   3          }
 830   2          num++;
 831   2      
 832   2          if (!next)
 833   2            break;
 834   2          str = next;
 835   2        }
 836   1        return num;
 837   1      }
 838          
 839          //EXPORT_SYMBOL(vsscanf);
 840          
 841          /**
 842           * sscanf - Unformat a buffer into a list of arguments
 843           * @buf:  input buffer
 844           * @fmt:  formatting of buffer
 845           * @...:  resulting arguments
 846           */
 847          int sscanf(const char * buf, const char * fmt, ...)
 848          {
 849   1        va_list args;
 850   1        int i;
 851   1      
 852   1        va_start(args,fmt);
 853   1        i = vsscanf(buf,fmt,args);
 854   1        va_end(args);
C51 COMPILER V9.52.0.0   VSPRINTF                                                          08/24/2017 10:20:54 PAGE 15  

 855   1        return i;
 856   1      }
 857          
 858          //EXPORT_SYMBOL(sscanf);

C51 COMPILATION COMPLETE.  1 WARNING(S),  2 ERROR(S)
