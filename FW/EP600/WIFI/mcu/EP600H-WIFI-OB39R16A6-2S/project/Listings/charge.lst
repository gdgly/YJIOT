C51 COMPILER V9.52.0.0   CHARGE                                                            01/11/2018 14:07:06 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE CHARGE
OBJECT MODULE PLACED IN .\Objects\charge.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\charge\charge.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\project;.\
                    -USER\BUZZER;.\USER\charge;.\USER\common;.\USER\DC_MOTOR;.\USER\EEPROM;.\USER\EXINT;.\USER\IIC;.\USER\inc;.\USER\ION;.\US
                    -ER\M26;.\USER\PWM;.\USER\Sensor;.\USER\step_motor;.\USER\SYS_RUN;.\USER\timer;.\USER\TM1620;.\USER\touch_key;.\USER\UART
                    -;.\USER\UV;.\USER\LVI) DEBUG OBJECTEXTEND PRINT(.\Listings\charge.lst) TABS(2) OBJECT(.\Objects\charge.obj)

line level    source

   1          #include <stdio.h>
   2          #include <string.h>
   3          #include "charge.h"
   4          #include "global.h"
*** WARNING C318 IN LINE 13 OF .\USER\inc\global.h: can't open file 'M26.h'
   5          #include "timer.h"
   6          #include "wifi_uart.h"
   7          #include "common.h"
   8          #include "debug_uart.h"
   9          #include "touch_key.h"
  10          #include "sys_run.h"
  11          #include "EEPROM.h"
  12          #include "M26.h"
*** WARNING C318 IN LINE 12 OF USER\charge\charge.c: can't open file 'M26.h'
  13          
  14          /*flash中存储方式大端法
  15          charge_info.lefttime.l_time = 2，则 charge_info.lefttime.c_time[0] = 0,charge_info.lefttime.c_time[1] = 0,
  16          charge_info.lefttime.c_time[2] = 0,charge_info.lefttime.c_time[3] = 2
  17          
  18          */
  19          
  20          Charge_Typedef charge_info;
  21          
  22          extern M26_Cmd_Typedef m26_cmd_info;
*** ERROR C129 IN LINE 22 OF USER\charge\charge.c: missing ';' before 'm26_cmd_info'
  23          
  24          #define CHARGE_INFO_LENGTH   5
  25          
  26          
  27          void charge_init(void)
  28          {
  29              //unsigned char i = 0; 
  30              unsigned char readbuff[10] ={0};
  31              unsigned int eeprom_addr = 0;
  32              
  33              eeprom_addr = EEPROM_START_ADDR | 0x00;
  34            
  35              mymemset(readbuff,0,sizeof(readbuff));
  36              EEPROM_Read_Bytes(readbuff,eeprom_addr,CHARGE_INFO_LENGTH);
  37            
  38          //    mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  39          //    sprintf(m26_cmd_info.sendtring,"read data:%d %d %d %d %d\r\n",(unsigned int)m26_cmd_info.cmd[0],(uns
             -igned int)m26_cmd_info.cmd[1],
  40          //             (unsigned int)m26_cmd_info.cmd[2],(unsigned int)m26_cmd_info.cmd[3],(unsigned int)m26_cmd_i
             -nfo.cmd[4]);
  41          //    DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
  42              
  43          //    mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  44          //    sprintf(m26_cmd_info.sendtring,"read data:%x %x %x %x %x\r\n",(unsigned int)readbuff[0],(unsigned in
             -t)readbuff[1],
  45          //             (unsigned int)readbuff[2],(unsigned int)readbuff[3],(unsigned int)readbuff[4]);
  46          //    DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
C51 COMPILER V9.52.0.0   CHARGE                                                            01/11/2018 14:07:06 PAGE 2   

  47              
  48          
  49              
  50              if(readbuff[0] > 1)
  51              {
  52                  //EEPROM_Page_Erase(EEPROM_START_ADDR);
  53                  //mymemset(readbuff,0,sizeof(readbuff));
  54                  //EEPROM_Read_Bytes(readbuff,eeprom_addr,CHARGE_INFO_LENGTH);
  55                
  56          //     mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  57          //    sprintf(m26_cmd_info.sendtring,"read data:%x %x %x %x %x\r\n",(unsigned int)readbuff[0],(unsigned in
             -t)readbuff[1],
  58          //             (unsigned int)readbuff[2],(unsigned int)readbuff[3],(unsigned int)readbuff[4]);
  59          //    DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
  60              }
  61                
  62              if(readbuff[0] == 0xFF)
  63              {
  64                
  65                  mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  66                  sprintf(m26_cmd_info.sendtring,"way0\r\n");
  67                  DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
  68                  //此种情况是第一次上电，设置为默认形式的家用机
  69                  //防止该page有的数据不是0xFF，所以执行一次擦除操作
  70                  EEPROM_Page_Erase(EEPROM_START_ADDR);
  71                    
  72                  mymemset(readbuff,0,sizeof(readbuff));
  73                  EEPROM_Write_Bytes(readbuff,EEPROM_START_ADDR,CHARGE_INFO_LENGTH);
  74                  //EEPROM_Write_Bytes(readbuff,EEPROM_START_ADDR,5);
  75                  //EEPROM_Byte_Program(EEPROM_START_ADDR,0);
  76                
  77              mymemset(readbuff,3,sizeof(readbuff));
  78              EEPROM_Read_Bytes(readbuff,(unsigned int)(EEPROM_START_ADDR),10);
  79          //    readbuff[0] = EEPROM_Byte_Read(EEPROM_START_ADDR);
  80          //    readbuff[1] = EEPROM_Byte_Read(EEPROM_START_ADDR + 1);
  81              mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  82              sprintf(m26_cmd_info.sendtring,"read data:%x %x %x %x %x %x\r\n",(unsigned int)readbuff[0],(unsigned i
             -nt)readbuff[1],
  83                       (unsigned int)readbuff[2],(unsigned int)readbuff[3],(unsigned int)readbuff[4],(unsigned int)r
             -eadbuff[5]);
  84              DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
  85                    
  86                  charge_info.IsChargeType = 0;
  87                  charge_info.lefttime.l_time = 0;
  88                  charge_info.eeprom_next_write_addr = eeprom_addr + CHARGE_INFO_LENGTH;
  89                    
  90                  goto exit;
  91                     
  92              }
  93              else
  94              {
  95                  eeprom_addr = eeprom_addr + CHARGE_INFO_LENGTH;
  96                
  97                  do{
  98                        mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
  99                        sprintf(m26_cmd_info.sendtring,"way3\r\n");
 100                        DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 101                        //每次读取2组数据，10个字节
 102                        mymemset(readbuff,0,sizeof(readbuff));
 103                        //EEPROM_Read_Bytes(readbuff,eeprom_addr,(CHARGE_INFO_LENGTH * 2));
 104                        EEPROM_Read_Bytes(readbuff,eeprom_addr,10);
 105                
C51 COMPILER V9.52.0.0   CHARGE                                                            01/11/2018 14:07:06 PAGE 3   

 106                        if(readbuff[0] == 0xFF || readbuff[5] == 0xFF)
 107                        {               
 108                            if(readbuff[0] == 0xFF)
 109                            {
 110                                mymemset(readbuff,0,sizeof(readbuff));
 111                                EEPROM_Read_Bytes(readbuff,(eeprom_addr - CHARGE_INFO_LENGTH),CHARGE_INFO_LENGTH);  
 112                    
 113                                charge_info.eeprom_next_write_addr = eeprom_addr;
 114                              
 115                                mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 116                                sprintf(m26_cmd_info.sendtring,"way1\r\n");
 117                                DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 118                            }
 119                            else
 120                            {
 121                                charge_info.eeprom_next_write_addr = eeprom_addr + CHARGE_INFO_LENGTH;
 122                              
 123                                mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 124                                sprintf(m26_cmd_info.sendtring,"way2\r\n");
 125                                DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 126                            }                    
 127                   
 128                            charge_info.IsChargeType = readbuff[0];
 129                            charge_info.lefttime.c_time[0] = readbuff[4];
 130                            charge_info.lefttime.c_time[1] = readbuff[3];
 131                            charge_info.lefttime.c_time[2] = readbuff[2];
 132                            charge_info.lefttime.c_time[3] = readbuff[1];
 133                                      
 134                            goto exit;         
 135                        }
 136                        
 137                        if(eeprom_addr < (EEPROM_END_ADDR - 9))
 138                        {
 139                            eeprom_addr += (CHARGE_INFO_LENGTH * 2);
 140                        }
 141                        else if(eeprom_addr == (EEPROM_END_ADDR - 9))              
 142                        {
 143                            //此种情况是有效数据是最后一组数据
 144                            charge_info.IsChargeType = readbuff[5];
 145                            charge_info.lefttime.c_time[0] = readbuff[9];
 146                            charge_info.lefttime.c_time[1] = readbuff[8];
 147                            charge_info.lefttime.c_time[2] = readbuff[7];
 148                            charge_info.lefttime.c_time[3] = readbuff[6];
 149                            //如果在执行flash写操作时，如果 charge_info.eeprom_write_addr == EEPROM_START_ADDR时，该
             -页被写满了，则需要先擦除，然后再从起始地址写
 150                            charge_info.eeprom_next_write_addr = EEPROM_START_ADDR;
 151                          
 152                            mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 153                            sprintf(m26_cmd_info.sendtring,"page full,re-write\r\n");
 154                            DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 155                          
 156                            goto exit;
 157                        }
 158                        else
 159                        {
 160                            //肯定出错了
 161                            mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 162                            sprintf(m26_cmd_info.sendtring,"eeprom addr out of range\r\n");
 163                            DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 164                          
 165                            charge_info.IsChargeType = 1;
 166                            charge_info.lefttime.l_time = 0;
C51 COMPILER V9.52.0.0   CHARGE                                                            01/11/2018 14:07:06 PAGE 4   

 167                          
 168                            charge_info.eeprom_next_write_addr = EEPROM_START_ADDR;
 169               
 170                            goto exit;
 171                        }             
 172              
 173                  }while(eeprom_addr < EEPROM_END_ADDR);    
 174              }
 175          exit:
 176          
 177              charge_info.next_1min_time = get_sys_stime() + (MIN_TO_S | 0x00);
 178              
 179              mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 180              sprintf(m26_cmd_info.sendtring,"find addr:%x\r\n",(unsigned int)charge_info.eeprom_next_write_addr);
 181              DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 182              
 183              mymemset(readbuff,0,sizeof(readbuff));
 184              EEPROM_Read_Bytes(readbuff,(unsigned int)(charge_info.eeprom_next_write_addr-5),10);
 185              mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 186              sprintf(m26_cmd_info.sendtring,"read data:%x %x %x %x %x %x\r\n",(unsigned int)readbuff[0],(unsigned i
             -nt)readbuff[1],
 187                       (unsigned int)readbuff[2],(unsigned int)readbuff[3],(unsigned int)readbuff[4],(unsigned int)r
             -eadbuff[5]);
 188              DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 189              
 190              mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 191              sprintf(m26_cmd_info.sendtring,"type:%d,time:%d\r\n",(unsigned int)charge_info.IsChargeType,(unsigned 
             -int)charge_info.lefttime.l_time);
 192              DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 193              
 194              
 195          }
 196          
 197          
 198          void charge_lefttime_flash_write(void)
 199          {
 200              unsigned char i = 0;
 201            
 202              if(charge_info.eeprom_next_write_addr == EEPROM_START_ADDR)
 203              {
 204                  EEPROM_Page_Erase(EEPROM_START_ADDR);
 205              }
 206              
 207              for(i = 0;i < CHARGE_INFO_LENGTH;i++)
 208              {
 209                  if(i == 0)
 210                  {
 211                      EEPROM_Byte_Program(charge_info.eeprom_next_write_addr,(unsigned char)charge_info.IsChargeType
             -);
 212                  }
 213                  else
 214                  {
 215                      EEPROM_Byte_Program(charge_info.eeprom_next_write_addr + i,charge_info.lefttime.c_time[4-i]);
 216                  }
 217              }
 218              
 219              if(charge_info.eeprom_next_write_addr > (EEPROM_END_ADDR - CHARGE_INFO_LENGTH))
 220              {
 221                  charge_info.eeprom_next_write_addr = EEPROM_START_ADDR;
 222              }
 223              else
 224              {
C51 COMPILER V9.52.0.0   CHARGE                                                            01/11/2018 14:07:06 PAGE 5   

 225                  charge_info.eeprom_next_write_addr += CHARGE_INFO_LENGTH;
 226              }
 227          }
 228          
 229          
 230          void charge_lefttime_count(void)
 231          {
 232              unsigned char readbuff[5] = {0};
 233              if(charge_info.IsChargeType == 0)
 234              {
 235                  return;
 236              }
 237              
 238              if(charge_info.lefttime.l_time == 0)
 239              {
 240                  return;
 241              }
 242              
 243              nowtime_s = get_sys_stime();   
 244              //防止时间溢出，正常情况下此处不会溢出
 245              if(nowtime_s < (MIN_TO_S | 0x00) && charge_info.next_1min_time >= 0xF0000000)
 246              {
 247                  charge_info.next_1min_time = nowtime_s + (MIN_TO_S | 0x00);
 248              }
 249              if(nowtime_s >= charge_info.next_1min_time)
 250              {
 251                  charge_info.lefttime.l_time -= 1;
 252                  charge_info.next_1min_time += (MIN_TO_S | 0x00);
 253                
 254                  if(charge_info.lefttime.l_time == 0)
 255                  {
 256                      charge_lefttime_flash_write();
 257                  }
 258                  
 259                  mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 260                  sprintf(m26_cmd_info.sendtring,"lefttime:%d\r\n",(unsigned int)(charge_info.lefttime.l_time));
 261                  DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 262                
 263          //        charge_lefttime_flash_write();
 264          //        mymemset(readbuff,0,sizeof(readbuff));
 265          //        EEPROM_Read_Bytes(readbuff,(unsigned int)(charge_info.eeprom_next_write_addr-5),5);
 266          //        mymemset(m26_cmd_info.sendtring,0,sizeof(m26_cmd_info.sendtring));
 267          //        sprintf(m26_cmd_info.sendtring,"read data:%x %x %x %x %x\r\n",(unsigned int)readbuff[0],(unsigne
             -d int)readbuff[1],
 268          //             (unsigned int)readbuff[2],(unsigned int)readbuff[3],(unsigned int)readbuff[4]);
 269          //        DEBUG_Uart_Sendbytes(m26_cmd_info.sendtring,strlen(m26_cmd_info.sendtring));
 270              }    
 271          }
 272          
 273          
 274          
 275          
 276          
 277          
 278          
 279          
 280          
 281          

C51 COMPILATION COMPLETE.  2 WARNING(S),  1 ERROR(S)
