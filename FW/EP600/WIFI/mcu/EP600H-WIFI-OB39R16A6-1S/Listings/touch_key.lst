C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/18/2017 15:06:11 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE TOUCH_KEY
OBJECT MODULE PLACED IN .\Objects\touch_key.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE USER\touch_key\touch_key.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER\
                    -IIC;.\USER\UART;.\USER\TM1618;.\USER\Sensor;.\USER;.\USER\PWM;.\USER\DC_MOTOR;.\USER\timer;.\USER\inc;.\USER\EXINT;.\USE
                    -R\touch_key;.\USER\SYS_RUN;.\USER\step_motor;.\USER\BUZZER;.\USER\UART;.\USER\common;.\USER\lib;.\USER\UV;.\USER\ION;.\U
                    -SER\EEPROM;.\USER\TM1620;.\USER\user_timer) DEBUG OBJECTEXTEND PRINT(.\Listings\touch_key.lst) TABS(2) OBJECT(.\Objects\
                    -touch_key.obj)

line level    source

   1          #include <stdio.h>
   2          #include "touch_key.h"
   3          #include "SOFT_IIC.h"
   4          #include "timer.h"
   5          #include "global.h"
   6          #include "debug_uart.h"
   7          #include "common.h"
   8          
   9          
  10          KEY_INFO_Typedef  key_info;
  11          
  12          
  13          #define KEY_IIC_DELAY_COUNT  10
  14          
  15          void key_i2c_delay(void)
  16          {
  17   1        int i = 0;
  18   1        for(i = 0;i < KEY_IIC_DELAY_COUNT;i++);
  19   1      }
  20          
  21          
  22          void Key_IIC_PinConifg(void)
  23          {
  24   1           
  25   1          KEY_IIC_PxM0 &= ~((1 << KEY_IIC_SDA_PORTBIT) | (1 << KEY_IIC_SCL_PORTBIT));
  26   1          KEY_IIC_PxM1 &= ~((1 << KEY_IIC_SDA_PORTBIT) | (1 << KEY_IIC_SCL_PORTBIT));
  27   1        
  28   1          KEY_IIC_SCL_PIN = 1;
  29   1          KEY_IIC_SDA_PIN = 1;
  30   1      }
  31          
  32          
  33          
  34          void Set_KEY_SDA_Pin_Mode(unsigned char mode)
  35          {
  36   1          if(mode == PIN_INPUT)
  37   1          {
  38   2              //PIN设置为输入时，PxM0对应的位置0，PxM1对应的位置1
  39   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SDA_PORTBIT);
  40   2              KEY_IIC_PxM1 |= (1 << KEY_IIC_SDA_PORTBIT);
  41   2          }
  42   1          else if(mode == PIN_OUTPUT)
  43   1          {      
  44   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SDA_PORTBIT);
  45   2              KEY_IIC_PxM1 &= ~(1 << KEY_IIC_SDA_PORTBIT);
  46   2          }
  47   1      }
  48            
  49          void Set_KEY_SCL_Pin_Mode(unsigned char mode)
  50          {
  51   1          if(mode == PIN_INPUT)
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/18/2017 15:06:11 PAGE 2   

  52   1          {
  53   2              //PIN设置为输入时，PxM0对应的位置0，PxM1对应的位置1
  54   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SCL_PORTBIT);
  55   2              KEY_IIC_PxM1 |= ((1 << KEY_IIC_SCL_PORTBIT));
  56   2          }
  57   1          else if(mode == PIN_OUTPUT)
  58   1          {      
  59   2              KEY_IIC_PxM0 &= ~(1 << KEY_IIC_SCL_PORTBIT);
  60   2              KEY_IIC_PxM1 &= ~(1 << KEY_IIC_SCL_PORTBIT);     
  61   2          }
  62   1      
  63   1      }
  64          
  65          
  66          void Key_IIC_SDA_1(void)
  67          {
  68   1          KEY_IIC_SDA_PIN = 1;
  69   1      }
  70          
  71          void Key_IIC_SDA_0(void)
  72          {
  73   1          KEY_IIC_SDA_PIN = 0;
  74   1      }
  75          
  76          void Key_IIC_SCL_1(void)
  77          {
  78   1          KEY_IIC_SCL_PIN = 1;
  79   1      }
  80          void Key_IIC_SCL_0(void)
  81          {
  82   1          KEY_IIC_SCL_PIN = 0;
  83   1      }
  84          
  85          
  86          unsigned char Key_IIC_SDA_READ(void)
  87          {
  88   1          return (KEY_IIC_SDA_PIN ? 1 : 0);
  89   1      }
  90          
  91          
  92          
  93          void Get_Key_Status(unsigned char *key_status)
  94          {
  95   1          const unsigned char readaddr = 0x17;
  96   1          unsigned char res = 1;
  97   1        
  98   1          IIC_Operations.IIC_NUM = TOUCH_KEY_IIC;
  99   1          IIC_Operations.Set_SDA_Pin_Mode = Set_KEY_SDA_Pin_Mode;
 100   1          IIC_Operations.Set_SCL_Pin_Mode = Set_KEY_SCL_Pin_Mode;
 101   1          IIC_Operations.i2c_delay = key_i2c_delay;
 102   1          IIC_Operations.SDA_1 = Key_IIC_SDA_1;
 103   1          IIC_Operations.SDA_0 = Key_IIC_SDA_0;
 104   1          IIC_Operations.SCL_1 = Key_IIC_SCL_1;
 105   1          IIC_Operations.SCL_0 = Key_IIC_SCL_0;
 106   1          IIC_Operations.I2C_SDA_READ = Key_IIC_SDA_READ;
 107   1        
 108   1          
 109   1          res = I2C_WriteBytes(OB39A08T1_ADDRESS,&readaddr,1);
 110   1          if(res == 0)
 111   1          {
 112   2              I2C_ReadBytes(OB39A08T1_ADDRESS,key_status,3);
 113   2          }
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/18/2017 15:06:11 PAGE 3   

 114   1          
 115   1      }
 116          
 117          unsigned char Scan_TouchPad(void)
 118          {
 119   1          static unsigned char wifi_key_count_times = 0;
 120   1          static unsigned char timer_key_count_times = 0;
 121   1          static unsigned char mode_key_count_times = 0;
 122   1          unsigned char whichkey = 0;
 123   1          unsigned char temp_status0,temp_status1 = 0;
 124   1          static unsigned char last_status0,last_status1 = 0;
 125   1        
 126   1          //unsigned char debug_buff[20] = {0};
 127   1        
 128   1          unsigned char key_status[3] = {0};
 129   1          
 130   1          //如果上电后检测到仓门坏了，则按键不起作用
 131   1          //如果仓门正在工作则按键不起作用
 132   1          if(IsStepMotorBusy)
 133   1          {
 134   2              return 0xFF;
 135   2          }
 136   1          
 137   1          Get_Key_Status(key_status);
 138   1        
 139   1          temp_status0 = key_status[2];
 140   1          temp_status1 = key_status[1];
 141   1        
 142   1          //POWER按键和其他按键不能同时按下
 143   1          if((temp_status0 == 0 && temp_status1 == 0) || (temp_status0 != 0 && temp_status1 != 0))
 144   1          {
 145   2              last_status0 = 0;
 146   2              last_status1 = 0;
 147   2            
 148   2              wifi_key_count_times = 0;
 149   2              timer_key_count_times = 0;
 150   2              mode_key_count_times = 0;
 151   2      
 152   2              Clear_Touch_Info();
 153   2              return 0;
 154   2          }
 155   1          
 156   1          if(temp_status0 != 0)
 157   1          {
 158   2              if(temp_status0 != last_status0)
 159   2              {
 160   3                  key_info.IsCount = 1;
 161   3                  key_info.count_times = 0;
 162   3                  key_info.IsTouchedKey = 0;
 163   3                  key_info.WhichKey = KEY_NONE;
 164   3              }
 165   2          }
 166   1          
 167   1          if(temp_status1 != 0)
 168   1          {
 169   2              if(temp_status1 != last_status1)
 170   2              {
 171   3                  key_info.IsCount = 1;
 172   3                  key_info.count_times = 0;
 173   3                  key_info.IsTouchedKey = 0;
 174   3                  key_info.WhichKey = KEY_NONE;
 175   3              }
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/18/2017 15:06:11 PAGE 4   

 176   2          }
 177   1          
 178   1          if(key_info.count_times >= (KEY_TOUCH_MS_TIMES * TIMER_BASE))
 179   1          {
 180   2              //一个按键计数完毕后停止计数，防止一直按着一个按键不松开
 181   2              if(temp_status1 != KEY_WIFI_VALUE && temp_status1 != KEY_TIMER_VALUE && temp_status1 != KEY_MODE_V
             -ALUE)
 182   2              {
 183   3                  key_info.IsCount = 0;
 184   3                  key_info.count_times = 0;
 185   3                
 186   3                  //如果不是按下wifi组合键，先把wifi计数清零
 187   3                  wifi_key_count_times = 0;
 188   3                  //如果不是按下timer键，先把timer计数清零
 189   3                  timer_key_count_times = 0;
 190   3                  //如果不是按下mode键，先把mode计数清零
 191   3                  mode_key_count_times = 0;
 192   3              }
 193   2              else
 194   2              {
 195   3                  //如果按下的是WIFI按键，则从0重新开始计数，直到检测到按下2秒钟以后再停止
 196   3                  key_info.count_times = 0;
 197   3              }
 198   2      
 199   2              
 200   2              if(temp_status0 != 0)
 201   2              {
 202   3                  if(temp_status0 == KEY_POWER_VALUE)
 203   3                  {
 204   4                      key_info.IsTouchedKey = 1;
 205   4                      key_info.WhichKey = KEY_POWER;
 206   4                  }
 207   3                  else
 208   3                  {
 209   4                      key_info.IsTouchedKey = 0;
 210   4                      key_info.WhichKey = KEY_NONE;
 211   4                  }
 212   3                  
 213   3                  wifi_key_count_times = 0;
 214   3              }
 215   2              
 216   2              if(temp_status1 != 0)
 217   2              {         
 218   3                  if(temp_status1 == KEY_SPEED_VALUE)
 219   3                  {
 220   4                      key_info.IsTouchedKey = 1;
 221   4                      key_info.WhichKey = KEY_SPEED;
 222   4                  }
 223   3                  else if(temp_status1 == KEY_TIMER_VALUE)
 224   3                  {
 225   4                      timer_key_count_times += 1;
 226   4                      if(timer_key_count_times >= (1000 / KEY_TOUCH_MS_TIMES))
 227   4                      {
 228   5                          key_info.IsTouchedKey = 1;
 229   5                          key_info.WhichKey = KEY_TIMER;
 230   5                        
 231   5                          //停止中断中的计数
 232   5                          key_info.IsCount = 0;
 233   5                          key_info.count_times = 0;
 234   5                          //此处timer_key_count_times不清零，防止一直按着组合键不松开，松开按键后再清零
 235   5                      }
 236   4                    
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/18/2017 15:06:11 PAGE 5   

 237   4                  }
 238   3                  else if(temp_status1 == KEY_MODE_VALUE)
 239   3                  {
 240   4                      mode_key_count_times += 1;
 241   4                      if(mode_key_count_times >= (1000 / KEY_TOUCH_MS_TIMES))
 242   4                      {
 243   5                          key_info.IsTouchedKey = 1;
 244   5                          key_info.WhichKey = KEY_MODE;
 245   5                        
 246   5                          //停止中断中的计数
 247   5                          key_info.IsCount = 0;
 248   5                          key_info.count_times = 0;
 249   5                          //此处mode_key_count_times不清零，防止一直按着组合键不松开，松开按键后再清零
 250   5                      }
 251   4                  }    
 252   3                  else if(temp_status1 == KEY_WIFI_VALUE)
 253   3                  {
 254   4                    
 255   4                      wifi_key_count_times += 1;
 256   4      //                mymemset(debug_buff,0,mystrlen(debug_buff));
 257   4      //                sprintf(debug_buff,"wifi_times:%d\n",(unsigned int)wifi_key_count_times);  
 258   4      //                DEBUG_Uart_Sendbytes(debug_buff,mystrlen(debug_buff));  
 259   4                    
 260   4                      if(wifi_key_count_times >= (2000 / KEY_TOUCH_MS_TIMES))
 261   4                      {
 262   5                          key_info.IsTouchedKey = 1;
 263   5                          key_info.WhichKey = KEY_WIFI;
 264   5                        
 265   5                          //停止中断中的计数
 266   5                          key_info.IsCount = 0;
 267   5                          key_info.count_times = 0;
 268   5                          //此处wifi_key_count_times不清零，防止一直按着组合键不松开，松开按键后再清零
 269   5                      }
 270   4                  }              
 271   3                  else
 272   3                  {
 273   4                      key_info.IsTouchedKey = 0;
 274   4                      key_info.WhichKey = KEY_NONE;            
 275   4                  }
 276   3                  
 277   3      
 278   3              }
 279   2                 
 280   2          }
 281   1              
 282   1          last_status0 = temp_status0;    
 283   1          last_status1 = temp_status1;
 284   1          
 285   1          return key_info.WhichKey;
 286   1      }
 287          
 288          
 289          void Clear_Touch_Info(void)
 290          {
 291   1          key_info.IsCount = 0;
 292   1          key_info.count_times = 0;
 293   1          key_info.IsTouchedKey = 0;
 294   1          key_info.WhichKey = KEY_NONE;
 295   1      }
 296          
 297          
 298          
C51 COMPILER V9.52.0.0   TOUCH_KEY                                                         12/18/2017 15:06:11 PAGE 6   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    665    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =     11      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
